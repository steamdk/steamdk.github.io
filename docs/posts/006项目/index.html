<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>006项目 | 项目介绍</title>
<meta name="keywords" content="cpp, 基础">
<meta name="description" content="webbench
测压软件 最高并发3W
webbench做测试时自身也会消耗CPU和内存资源，为了测试准确，需要将webbench安装在别的服务器上。
tar -xzvf webbench-1.5.tar.gz
cd webbench-1.5
apt-get install ctags
make &amp;&amp; make install
测试">
<meta name="author" content="steamdk">
<link rel="canonical" href="https://steamdk.github.io/posts/006%E9%A1%B9%E7%9B%AE/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0dacc8c7e73304b031a6a2212c5729fafb119196b4d02d3b299eb05a4bd0b2a9.css" integrity="sha256-DazIx&#43;czBLAxpqIhLFcp&#43;vsRkZa00C07KZ6wWkvQsqk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://steamdk.github.io/favicon.svg">
<link rel="icon" type="image/png" sizes="16x16" href="https://steamdk.github.io/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="https://steamdk.github.io/favicon.svg">
<link rel="apple-touch-icon" href="https://steamdk.github.io/favicon.svg">
<link rel="mask-icon" href="https://steamdk.github.io/favicon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://steamdk.github.io/posts/006%E9%A1%B9%E7%9B%AE/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">





<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style><meta property="og:url" content="https://steamdk.github.io/posts/006%E9%A1%B9%E7%9B%AE/">
  <meta property="og:site_name" content="项目介绍">
  <meta property="og:title" content="006项目">
  <meta property="og:description" content="webbench 测压软件 最高并发3W
webbench做测试时自身也会消耗CPU和内存资源，为了测试准确，需要将webbench安装在别的服务器上。
tar -xzvf webbench-1.5.tar.gz cd webbench-1.5 apt-get install ctags make &amp;&amp; make install 测试">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-14T21:59:02+08:00">
    <meta property="article:modified_time" content="2024-09-14T21:59:02+08:00">
    <meta property="article:tag" content="Cpp">
    <meta property="article:tag" content="基础">
      <meta property="og:image" content="https://i.postimg.cc/7hwBy7VS/calcr.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.postimg.cc/7hwBy7VS/calcr.png">
<meta name="twitter:title" content="006项目">
<meta name="twitter:description" content="webbench
测压软件 最高并发3W
webbench做测试时自身也会消耗CPU和内存资源，为了测试准确，需要将webbench安装在别的服务器上。
tar -xzvf webbench-1.5.tar.gz
cd webbench-1.5
apt-get install ctags
make &amp;&amp; make install
测试">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://steamdk.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "006项目",
      "item": "https://steamdk.github.io/posts/006%E9%A1%B9%E7%9B%AE/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "006项目",
  "name": "006项目",
  "description": "webbench 测压软件 最高并发3W\nwebbench做测试时自身也会消耗CPU和内存资源，为了测试准确，需要将webbench安装在别的服务器上。\ntar -xzvf webbench-1.5.tar.gz cd webbench-1.5 apt-get install ctags make \u0026amp;\u0026amp; make install 测试\n",
  "keywords": [
    "cpp", "基础"
  ],
  "articleBody": "webbench 测压软件 最高并发3W\nwebbench做测试时自身也会消耗CPU和内存资源，为了测试准确，需要将webbench安装在别的服务器上。\ntar -xzvf webbench-1.5.tar.gz cd webbench-1.5 apt-get install ctags make \u0026\u0026 make install 测试\nwebbench -c 1000 -t 5 http://127.0.0.1:9999/index.html //1000个客户端 5秒钟时间 github git clone https://github.com/SYaoJun/WebServer.git //把仓库中的内容拷贝到linux系统中 回调函数 函数指针本身是指针变量，指向某个函数的入口地址。\n#include #include int run(void(*step)(void)){ //回调函数的传参是声明的格式 int cnt = 0; while(1){ if(step != NULL) step(); cnt++; sleep(1); } return 0; } void cb(void){ //回调函数 puts(\"记秒到时\"); } int main(){ run(cb); return 0; } gcc cb.c main.c 信号函数 raise(SIGSEGV) //自己给自己进程发送信号 11 abort() //终止当前进程 测试1s打印多少个数\nalarm函数\n#include #include int main(){ alarm(1); //计时1s 到时后内核发送一个sigalarm信号终止 for(int i = 0;;i++) printf(\"%d\\n\", i); return 0; } setitimer函数\n#include #include #include #include int my_alarm(int sec){ struct itimerval it, oldit; it.it_value.tv_sec = sec; //定时长度 it.it_value.tv_usec = 0; //微秒 it.it_interval.tv_sec = 0; //周期定时 it.it_interval.tv_usec = 0; int ret = setitimer(ITIMER_REAL, \u0026it, \u0026oldit); if(ret == -1){ perror(\"setitimer error\"); exit(1); } return oldit.it_value.tv_sec; } int main(){ my_alarm(1); //计时1s 到时后内核发送一个sigalarm信号终止 for(int i = 0;;i++) printf(\"%d\\n\", i); return 0; } 创建线程 #include #include #include #include void* func(void* arg){ //必须为这种类型 printf(\"in thread : thread id: %lu, process id: %u\\n\", pthread_self(), getpid()); } int main(void){ //创建线程 pthread_t tid; //重命名的unsigned long 类型 //创建线程API pthread_create(arg1, agr2, arg3, arg4) //arg1: 传入的线程tid地址 //arg2: 线程属性 通常设置为NULL //arg3: 线程执行的任务 函数指针 //arg4: 参数3传递的参数 printf(\"in main 1 : thread id: %lu, process id: %u\\n\", pthread_self(), getpid()); int ret = pthread_create(\u0026tid, NULL, func, NULL); if(ret != 0){ perror(\"pthread_create error\"); exit(1); } sleep(1); //主线程 等待子线程执行完毕 printf(\"in main 2 : thread id: %lu, process id: %u\\n\", pthread_self(), getpid()); return 0; } 创建多个子线程 #include #include #include #include #include void* func(void* arg){ //必须为这种类型 int i = (int)arg; printf(\"%dth thread id: %lu, process id: %u\\n\", i, pthread_self(), getpid()); } int main(void){ //创建线程 pthread_t tid; //重命名的unsigned long 类型 //创建线程API pthread_create(arg1, agr2, arg3, arg4) //arg1: 传入的线程tid地址 //arg2: 线程属性 通常设置为NULL //arg3: 线程执行的任务 函数指针 //arg4: 参数3传递的参数 int n = 5, ret; for(int i = 0; i \u003c n; i++){ ret = pthread_create(\u0026tid, NULL, func, (void*)i); if(ret != 0){ fprintf(stderr, \"%s pthread_create error\", strerror(ret)); exit(1); } pthread_detach(tid); } sleep(n); //主线程 等待子线程执行完毕 return 0; } mysql使用 mysql在linux环境下结合C语言的使用\nsudo apt-get install mysql-client mysql-server //先安装mysql sudo apt-get install libmysql++-dev //安装库 先启动mysql库 设置好密码 然后使用c程序连接\n#include #include #include int main(){ MYSQL mysql; MYSQL_RES *res; MYSQL_ROW row; int i, j; char *query = \"select * from people;\"; mysql_init(\u0026mysql); //初始化 if(!mysql_real_connect(\u0026mysql,\"localhost\",\"root\",\"password\",\"yaojun\",3306,NULL,0)){ //连接数据库 printf(\"Error in connecting\"); } if(mysql_query(\u0026mysql,query)){ //查询数据库 printf(\"Error in querying\"); } res = mysql_store_result(\u0026mysql); while(row = mysql_fetch_row(res)){ //读取数据库中的一行 for(i=0;i\u003cmysql_num_fields(res);i++){ fprintf(stdout,\"%s \",row[i]); } printf(\"\\n\"); } mysql_free_result(res); //释放 mysql_close(\u0026mysql); //关闭 return 0; } 编译的命令\ngcc sql.c -lmysqlclient //生成a.out文件 执行 指针和数组 char str[]=\"hello\"; //字符串含\\0 6字节 char *url =\"hello\"; //指针64位机 8字节 cout\u003c\u003csizeof(str)\u003c\u003c\" \"\u003c\u003csizeof(url)\u003c\u003cendl; CGI服务器 原理：输出到某个文件描述符上的内容直接发送到客户端连接对应的socket上，此处我们模拟了把服务器端输出到标准输出的内容，直接发送给客户端。\n测试\ntelnet 127.0.0.1 6666 #include #include #include #include #include #include #include #include #include #include //命令行参数指定IP和端口 int main(int argc, char *argv[]){ if(argc \u003c= 2){ printf(\"at least 3 arguments: file ip port, but you give %d\\n\", argc); return 1; } const char* ip = argv[1]; int port = atoi(argv[2]); int lfd, cfd, ret; struct sockaddr_in serv_addr, clie_addr; lfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字 assert(lfd \u003e= 0); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(port); inet_pton(AF_INET, ip, \u0026serv_addr.sin_addr); //端口复用 此处没有卵用 int opt = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, \u0026opt, sizeof(opt)); ret = bind(lfd, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr) ); assert(ret != -1); ret = listen(lfd, 128); //最大同时连接数 assert(ret != -1); socklen_t clie_addr_len; //套接字长度 clie_addr_len = sizeof(clie_addr); cfd = accept(lfd, (struct sockaddr*)\u0026clie_addr, \u0026clie_addr_len ); if(cfd \u003c 0){ printf(\"accept error: %d\", errno); }else{ close(STDOUT_FILENO); dup(cfd); //创建一个新的文件描述符 该文件描述符和原文件描述符指向相同的文件 管道和网络连接 printf(\"good night! daisy!\\n\"); close(cfd); } close(lfd); return 0; } EPOLLONESHOT事件 一个socket上的某个事件被触发多次，可能产生2个不同的线程处理同一个socket。我们期望的是一个socket在任一时刻都只被一个线程处理。对于注册了EPOLLONESHOT事件的文件描述符，操做系统最多触发其上注册的一个可读可写或者异常事件一次。注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，应立即重置这个socket上的EPOLLONESHOT事件。\n监听socket不应设置为EPOLLONESHOT。\n#include #include #include #include #include #include #include #include #include #include #include #include #include #define MAX_SIZE 1024 //自定义的结构体 struct fds{ int epollfd; int sockfd; }; //设置文件描述符为非阻塞 void setnonblocking(int fd){ int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); } //添加到epoll内核事件表中 void addfd(int epollfd, int fd, bool oneshot){ epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET; if(oneshot){ event.events |= EPOLLONESHOT; } epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, \u0026event); //挂到红黑树上 setnonblocking(fd); //设置非阻塞 主要用在读写上 } //重置EPOLLONESHOT事件 void reset_oneshot(int epollfd, int fd){ epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET | EPOLLONESHOT; epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, \u0026event); //修改注册事件 } //工作线程 void* worker(void* arg){ int sockfd = ((fds*)arg)-\u003esockfd; int epollfd = ((fds*)arg)-\u003eepollfd; printf(\"start new thread to receive data on fd: %d\\n\", sockfd); char buf[MAX_SIZE]; memset(buf, '\\0', MAX_SIZE); //循环读取sockfd上的数据 直到收到EAGAIN while(1){ int ret = recv(sockfd, buf, MAX_SIZE-1, 0); if(ret == 0){ close(sockfd); printf(\"foreiner closed the connection\\n\"); break; }else if(ret \u003c 0){ if(errno == EAGAIN){ reset_oneshot(epollfd ,sockfd); printf(\"read later\\n\"); break; } }else{ printf(\"get connection: %s\\n\", buf); //休眠5s模拟数据处理过程 sleep(5); } } printf(\"end thread receiving data on fd: %d\\n\", sockfd); } //命令行参数指定IP和端口 int main(int argc, char *argv[]){ if(argc \u003c= 2){ printf(\"at least 3 arguments: file ip port, but you give %d\\n\", argc); return 1; } const char* ip = argv[1]; int port = atoi(argv[2]); int lfd, cfd, ret; struct sockaddr_in serv_addr, clie_addr; lfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字 assert(lfd \u003e= 0); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(port); inet_pton(AF_INET, ip, \u0026serv_addr.sin_addr); //端口复用 此处没有卵用 int opt = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, \u0026opt, sizeof(opt)); ret = bind(lfd, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr) ); assert(ret != -1); ret = listen(lfd, 128); //最大同时连接数 assert(ret != -1); epoll_event events[MAX_SIZE]; //返回的数组上限 int epollfd = epoll_create(10); assert(epollfd != -1); //注意监听的套接字不能设置为oneshot addfd(epollfd, lfd, false); //挂上红黑树监听 printf(\"addfd\\n\"); while(1){ ret = epoll_wait(epollfd, events, MAX_SIZE, -1); //永远不超时 if(ret \u003c 0){ printf(\"epoll failure\\n\"); break; } for(int i = 0; i \u003c ret; i++){ //循环处理有响应的事件 int sockfd = events[i].data.fd; if(sockfd == lfd){ //如果是监听事件则建立新的连接 printf(\"lfd\\n\"); socklen_t clie_addr_len; //套接字长度 clie_addr_len = sizeof(clie_addr); cfd = accept(lfd, (struct sockaddr*)\u0026clie_addr, \u0026clie_addr_len ); assert(cfd \u003e= 0); //注册为oneshot事件 addfd(epollfd, cfd, true); //刚刚这里加入的事件加错了 }else if(events[i].events \u0026 EPOLLIN){ pthread_t tid; fds fds_for_new_worker; fds_for_new_worker.epollfd = epollfd; fds_for_new_worker.sockfd = sockfd; //新启动一个线程为sockfd服务 pthread_create(\u0026tid, NULL, worker, (void*)\u0026fds_for_new_worker); // pthread_detach(tid); //线程分离 } } } close(lfd); return 0; } 信号屏蔽字 主要函数\nsigaddset() sigprocmask() sigpending() 使用kill发送信号\nkill -6 PID 测试程序\n#include #include #include void print(sigset_t* ped){ for(int i = 0; i \u003c 32; i++){ if(sigismember(ped, i)==1){ putchar('1'); }else putchar('0'); } printf(\"\\n\"); } int main(void){ sigset_t myset, oldset, ped; sigemptyset(\u0026myset); //设置自定义信号集 sigaddset(\u0026myset, SIGINT); sigaddset(\u0026myset, SIGSEGV); sigaddset(\u0026myset, SIGQUIT); sigaddset(\u0026myset, SIGABRT); //设置信号屏蔽字 sigprocmask(SIG_BLOCK, \u0026myset, \u0026oldset); while(1){ sigpending(\u0026ped); print(\u0026ped); sleep(2); } return 0; } sigaction信号捕捉函数 #include #include #include void docatch(int signo){ printf(\"%d signal has been catched!\\n\", signo); } int main(void){ struct sigaction act; act.sa_handler = docatch; sigemptyset(\u0026act.sa_mask); sigaddset(\u0026act.sa_mask, SIGINT); sigaddset(\u0026act.sa_mask, SIGSEGV); sigaddset(\u0026act.sa_mask, SIGQUIT); act.sa_flags = 0; //默认属性 在信号函数处理期间 本信号再次到达默认屏蔽 sigaction(SIGINT, \u0026act, NULL); while(1); return 0; } 统一事件源 把信号事件的处理放到epoll监听事件中去处理，统一了事件源。当调用信号处理函数时，信号处理函数通过管道将信息传达给epoll上的读端监听事件，再在主循环中处理事件。\n#include #include #include #include #include #include #include #include #include #include #include #include #include #include #define MAX_SIZE 1024 //自定义的结构体 static int pipefd[2]; struct fds{ int epollfd; int sockfd; }; //设置文件描述符为非阻塞 void setnonblocking(int fd){ int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); } //添加到epoll内核事件表中 void addfd(int epollfd, int fd, bool oneshot){ epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET; if(oneshot){ event.events |= EPOLLONESHOT; } epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, \u0026event); //挂到红黑树上 setnonblocking(fd); //设置非阻塞 主要用在读写上 } //信号处理函数 void sig_handler(int sig){ int save_errno = errno; int msg = sig; //我猜想这里重新定义变量的原因在于传的是指针 同时为了保证可重入 send(pipefd[1], (char*)\u0026msg, 1, 0); //pipefd[1]是非阻塞的如果发不出去直接返回 errno = save_errno; } //设置信号处理 void addsig(int sig){ struct sigaction sa; memset(\u0026sa, '\\0', sizeof(sa)); sa.sa_handler = sig_handler; sa.sa_flags |= SA_RESTART; sigfillset(\u0026sa.sa_mask); // sigaddset(\u0026sa.sa_mask, SIGSEGV); assert(sigaction(sig, \u0026sa, NULL) != -1); //注册监听的信号 } //命令行参数指定IP和端口 int main(int argc, char *argv[]){ if(argc \u003c= 2){ printf(\"at least 3 arguments: file ip port, but you give %d\\n\", argc); return 1; } const char* ip = argv[1]; int port = atoi(argv[2]); int lfd, cfd, ret; struct sockaddr_in serv_addr, clie_addr; lfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字 assert(lfd \u003e= 0); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(port); inet_pton(AF_INET, ip, \u0026serv_addr.sin_addr); //端口复用 此处没有卵用 int opt = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, \u0026opt, sizeof(opt)); //忽略SIGPIPE信号 signal(SIGPIPE, SIG_IGN); ret = bind(lfd, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr) ); assert(ret != -1); ret = listen(lfd, 128); //最大同时连接数 assert(ret != -1); epoll_event events[MAX_SIZE]; //返回的数组上限 int epollfd = epoll_create(10); assert(epollfd != -1); //注意监听的套接字不能设置为oneshot addfd(epollfd, lfd, false); //挂上红黑树监听 /*使用socketpair创建全双工的管道*/ ret = socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd); assert(ret != -1); setnonblocking(pipefd[1]); //把写入的管道端置为非阻塞 addfd( epollfd, pipefd[0], false); //设置为oneshot /*设置一些信号的处理函数*/ addsig(SIGHUP); addsig(SIGCHLD); addsig(SIGTERM); addsig(SIGINT); addsig(SIGSEGV); bool stop_server = false; while(!stop_server){ printf(\"epoll_wait...\\n\"); ret = epoll_wait(epollfd, events, MAX_SIZE, -1); //永远不超时 if((ret \u003c 0) \u0026\u0026 (errno != EINTR)){ //这里要设置 被系统调用打断的不算失败 errno不是ret perror(\"epoll failure\"); exit(1); } for(int i = 0; i \u003c ret; i++){ //循环处理有响应的事件 int sockfd = events[i].data.fd; if(sockfd == lfd){ //如果是监听事件则建立新的连接 socklen_t clie_addr_len; //套接字长度 clie_addr_len = sizeof(clie_addr); cfd = accept(lfd, (struct sockaddr*)\u0026clie_addr, \u0026clie_addr_len ); assert(cfd \u003e= 0); //注册为oneshot事件 addfd(epollfd, cfd, true); /*如果就绪的文件描述符是pipefd[0],就处理信号*/ }else if((sockfd == pipefd[0]) \u0026\u0026(events[i].events \u0026 EPOLLIN)){ char buf[MAX_SIZE]; int num = recv(pipefd[0], buf, sizeof(buf), 0); if(num == -1) continue; else if(num == 0) continue; else{ //可能管道有多个信号满足 每次读出一个字符进行处理 for(int j = 0; j \u003c num; j++){ switch(buf[j]){ case SIGSEGV: puts(\"段错误信号已处理，收到请回答！\"); break; case SIGCHLD: case SIGHUP: continue; case SIGTERM: case SIGINT: stop_server = true;break; } } } }else{} } } printf(\"close fds\\n\"); close(lfd); close(pipefd[0]); close(pipefd[1]); return 0; } 单例模式 #include #include #include using namespace std; class Singleton{ private: //无法调用构造函数 Singleton(); Singleton(const Singleton\u0026 other); public: static Singleton* getInstance(); static Singleton* m_instance; } Singleton* Singleton::m_instance = nullptr; //懒汉式 单线程版 Singleton* Singleton::getInstance(){ if(m_instance == nullptr){ m_instance = new Singleton(); } return m_instance; } //多线程版 Singleton* Singleton::getInstance(){ LOCK lock; if(m_instance == nullptr){ m_instance = new Singleton(); } return m_instance; } 当前时间 #include #include #include #include int main(void){ time_t tm; time(\u0026tm); char time_string[128]; ctime_r(\u0026tm, time_string); printf(\"%s\", time_string); return 0; } 初阶日志系统 #include #include #include #include #include #include #include #include #include #include #include using namespace std; class Logger{ public: static Logger* get_instance(); static Logger* log; static mutex log_mutex; static void write_log(int level, char* s); static void create_file(); static int fd; private: Logger(); Logger(const Logger\u0026 other); ~Logger(); }; Logger* Logger::log = NULL; mutex Logger::log_mutex; int Logger::fd = 0; Logger::Logger(){}; Logger::~Logger(){ if(log != NULL){ delete log; log = NULL; } close(fd); } Logger* Logger::get_instance(){ if(log == NULL){ log_mutex.lock(); if(log == NULL){ log = new Logger(); } log_mutex.unlock(); } return log; } void Logger::create_file(){ fd = open(\"logger.txt\", O_RDWR|O_CREAT|O_TRUNC, 777); assert(fd \u003e 0); } void Logger::write_log(int level, char* s){ int n = strlen(s); log_mutex.lock(); write(fd, s, n); log_mutex.unlock(); } 单例模式 //C++11 atomic std::atomic\u003cLogger*\u003e Logger::log; std::mutex Logger::log_mutex; Logger* Logger::get_instance(){ Logger* tmp = log.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire); //获取内存fence if(tmp == NULL){ std::lock_guard\u003cstd::mutex\u003e lock(log_mutex); tmp = log.load(std::memory_order_relaxed); if(tmp == NUll){ tmp = new Logger; std::atomic_thread_fence(std::memory_order_release); //释放内存fence log.store(tmp, std::memory_order_relaxed); } } return tmp; } 主线程测试 #include #include #include #include #include #include \"logger.h\" void* func(void* arg){ char buf[1024]; sprintf(buf, \"thread id: %lu, process id: %u\\n\", pthread_self(), getpid()); Logger::log-\u003ewrite_log(2, buf); } int main(void){ pthread_t tid; //重命名的unsigned long 类型 Logger::log-\u003ecreate_file(); int n = 5, ret; for(int i = 0; i \u003c n; i++){ // int t = i; ret = pthread_create(\u0026tid, NULL, func, NULL); if(ret != 0){ fprintf(stderr, \"%s pthread_create error\", strerror(ret)); exit(1); } pthread_detach(tid); } sleep(n-4); //主线程 等待子线程执行完毕 return 0; } 时间堆 把监听文件描述符加入后，就启动定时器。\nexec函数族 在一个程序中运行另一个程序。当进程调用exec函数时，该进程的用户空间代码和数据完全被新程序替换。调用exec并不创建新进程，所以调用exec前后进程的ID并不改变。\n#include #include #include int main(){ pid_t pid = fork(); if(pid == -1){ perror(\"fork error!\"); exit(-1); }else if(pid == 0){ execlp(\"ls\", \"anythingok\", \"-l\", \"-a\", NULL); }else if(pid \u003e 0){ sleep(1); puts(\"parent over!\"); } return 0; } 管道 #include #include #include int main(){ pid_t fd[2]; pipe(fd); //创建管道 int ret = fork(); if(ret \u003e 0){ //父进程 父写 fd[0]读 fd[1]写 close(fd[0]); char *str =\"hello world\\n\"; write(fd[1], str, strlen(str)); sleep(1); }else if(ret == 0){ //子进程 子读 fd[1]关闭 close(fd[1]); char buf[1024]; int n = read(fd[0], buf, sizeof(buf)); //写到显示器上 write(1, buf, n); } return 0; } CGI使用管道和exec实现 hello里面的输入和输出都被重定向了\n#include #include #include #include #include int main(int agrc, char* argv[]){ char bf[100]; read(STDIN_FILENO, bf, sizeof(bf)); sprintf(bf, \"Content-Type:text/html;\\r\\n\\r\\nhello world, 你好!\"); printf(\"%s\", bf); return 0; } 主进程调用已经编译完毕的hello可执行文件\n#include #include #include #include #include #include int main(){ pid_t pid; int status; int cgi_input[2]; int cgi_output[2]; char buf[1024]; /*创建输入管道*/ if(pipe(cgi_input) \u003c 0){ perror(\"pipe error\"); exit(1); } /*创建输出管道*/ if(pipe(cgi_output) \u003c 0){ perror(\"pipe error\"); exit(1); } /*创建子进程*/ if((pid = fork()) \u003c 0){ perror(\"fork error!\"); exit(-1); } if(pid == 0){ dup2(cgi_input[0], 0); /*将子进程的STDIN重定向到cgi_input[0]*/ dup2(cgi_output[1], 1); /*将子进程的STDOUT重定向到cgi_output[1]*/ /*关闭剩余的两端*/ close(cgi_input[1]); close(cgi_output[0]); /*执行exec文件 即cgi*/ execl(\"hello\", \"anythingok\", NULL); exit(0); }else if(pid \u003e 0){ /*父进程先给子进程发送数据 然后等待子进程执行完 再读数据*/ /*关闭不用的两个端口*/ close(cgi_input[0]); close(cgi_output[1]); char tmp[100]=\"hello child process\"; int len = strlen(tmp); /*父进程先写数据*/ write(cgi_input[1], tmp, len); /*父进程阻塞等待读入*/ int n = read(cgi_output[0], buf, sizeof(buf)); int ret = write(STDOUT_FILENO, buf, n); /*关闭管道*/ close(cgi_input[1]); close(cgi_output[0]); waitpid(pid, \u0026status, 0); } return 0; } 多线程服务器 #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #define SERV_PORT 9999 #define MAXSIZE 2048 void wait_child(int signo){ while(waitpid(0, NULL, WNOHANG) \u003e 0); return; } int createlistenfd(){ struct sockaddr_in servaddr; int ret; int fd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字 if(fd == -1){ perror(\"socket error\"); exit(1); } //初始化servaddr结构体 bzero(\u0026servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(SERV_PORT); servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //端口复用 int opt = 1; setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, \u0026opt, sizeof(opt)); //绑定端口 ret = bind(fd, (struct sockaddr *)\u0026servaddr, sizeof(servaddr)); if (ret == -1){ perror(\"bind error\"); exit(1); } //设置监听上限 ret = listen(fd, 128); if(ret==-1){ perror(\"listen error\"); exit(1); } return fd; } void work(int cfd, char* s){ char filename[100]={0}; sscanf(s, \"GET /%s\", filename); char *mime; if(strstr(s, \".html\")) mime = \"text/html\"; else if(strstr(s, \".jpg\")) mime=\"image/jpeg\"; //构建响应头 发给客户端 // printf(\"%s\\n\", filename); char response[MAXSIZE]; sprintf(response, \"HTTP/1.1 200 OK\\r\\nContent-Type: %s\\r\\n\\r\\n\", mime); //读取具体的文件内容 int filefd = open(filename, O_RDONLY); if(filefd == -1){ perror(\"open error\"); sleep(0.5); filefd = open(filename, O_RDONLY); //很奇怪 为什么睡几秒钟之后再打开就不会出错了 if(filefd == -1) exit(1); } int len = strlen(response); int n = read(filefd, response+len, sizeof(response)-len); write(cfd, response, len+n); close(filefd); } int main(void){ int lfd = createlistenfd(); struct sockaddr_in clientaddr; socklen_t clientaddrlen = sizeof(clientaddr); //这是一个传出参数 //accept接受连接请求 pid_t pid; int cfd; while(1){ cfd = accept(lfd, (struct sockaddr *)\u0026clientaddr, \u0026clientaddrlen); if (cfd == -1){ perror(\"accept error\"); exit(1); } //创建子线程 主线程负责监听和回收子进程 pid = fork(); if(pid \u003c 0){ perror(\"fork error\"); exit(1); } else if(pid == 0) break; else{ close(cfd); //关闭接收文件描述符 signal(SIGCHLD, wait_child); } } if(pid == 0){ close(lfd); //关闭监听文件描述符 //打印客户端IP和port char buf[MAXSIZE] = {0}; printf(\"client IP: %s, client port: %d\\n\", inet_ntop(AF_INET, \u0026clientaddr.sin_addr, buf, sizeof(buf)), ntohs(clientaddr.sin_port)); int n = read(cfd, buf, sizeof(buf)); if(n==0){ close(cfd); } // write(1, buf, n); else work(cfd, buf); } return 0; } 处理客户端注册信息的cgi 存在一些问题，每个网页好像没有传输完成，浏览器总是转圈。 需要结合上面hello程序查询数据库，hello程序的注册还没完善，只能做到查询。等以后有空再做吧。 #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include #define MAX_SIZE 1024 //自定义的结构体 struct fds{ int epollfd; int sockfd; }; //设置文件描述符为非阻塞 void setnonblocking(int fd){ int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); } //添加到epoll内核事件表中 void addfd(int epollfd, int fd, bool oneshot){ epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET; if(oneshot){ event.events |= EPOLLONESHOT; } epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, \u0026event); //挂到红黑树上 setnonblocking(fd); //设置非阻塞 主要用在读写上 } //移除epoll事件 void removefd(int epollfd, int fd){ epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, NULL); close(fd); } //重置EPOLLONESHOT事件 void reset_oneshot(int epollfd, int fd){ epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET | EPOLLONESHOT; epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, \u0026event); //修改注册事件 } void accept_request(int epollfd, int sockfd, char *s){ char method[32], filename[32], account[32], password[32], phone[32]; sscanf(s, \"%s /%s\", method, filename); if(strcasecmp(method, \"POST\") == 0){ int len = strlen(s); int i; for(i = 0; i \u003c len; i++){ if(i+2\u003clen \u0026\u0026 s[i]=='\\n' \u0026\u0026 s[i+1]=='\\r') break; } int j; i=i+12; for(j = 0; s[i+j]!='\u0026'; j++) account[j] = s[j+i]; i = i+j+6; for(j = 0; s[i+j]!='\u0026'; j++) password[j] = s[j+i]; /*2020.4.7成功解析出来账号和密码*/ pid_t pid; int status; int cgi_input[2]; int cgi_output[2]; char buff[1024]; /*创建输入管道*/ if(pipe(cgi_input) \u003c 0){ perror(\"pipe error\"); exit(1); } /*创建输出管道*/ if(pipe(cgi_output) \u003c 0){ perror(\"pipe error\"); exit(1); } /*创建子进程*/ if((pid = fork()) \u003c 0){ perror(\"fork error!\"); exit(-1); } if(pid == 0){ dup2(cgi_input[0], 0); /*将子进程的STDIN重定向到cgi_input[0]*/ dup2(cgi_output[1], 1); /*将子进程的STDOUT重定向到cgi_output[1]*/ /*关闭剩余的两端*/ close(cgi_input[1]); close(cgi_output[0]); /*执行exec文件 即cgi*/ execl(\"hello\", \"anythingok\", NULL); exit(0); }else if(pid \u003e 0){ /*父进程先给子进程发送数据 然后等待子进程执行完 再读数据*/ /*关闭不用的两个端口*/ close(cgi_input[0]); close(cgi_output[1]); /*父进程先写数据*/ int len = strlen(account); write(cgi_input[1], account, len); /*父进程阻塞等待读入*/ int n = read(cgi_output[0], buff, sizeof(buff)); if(strcmp(buff, password)==0\u0026\u0026strlen(password) != 0){ puts(\"密码正确\"); }else{ puts(\"密码错误\"); strcpy(filename, \"register.html\"); } // int ret = write(STDOUT_FILENO, buf, n); /*关闭管道*/ close(cgi_input[1]); close(cgi_output[0]); waitpid(pid, \u0026status, 0); } } puts(filename); char mime[64]; if(strstr(s, \".html\")) strcpy(mime,\"text/html\"); else if(strstr(s, \".jpg\")) strcpy(mime,\"image/jpeg\"); char response[MAX_SIZE+MAX_SIZE]; sprintf(response, \"HTTP/1.1 200 OK\\r\\nContent-Type: %s\\r\\n\\r\\n\", mime); int filefd = open(filename, O_RDONLY); if(filefd == -1){ perror(\"open error\"); exit(1); } int len = strlen(response); int n = read(filefd, response+len, sizeof(response)-len); write(sockfd, response, len+n); close(filefd); } //工作线程 void* worker(void* arg){ int sockfd = ((fds*)arg)-\u003esockfd; int epollfd = ((fds*)arg)-\u003eepollfd; char buf[MAX_SIZE]; memset(buf, '\\0', MAX_SIZE); //循环读取sockfd上的数据 直到收到EAGAIN while(1){ int ret = recv(sockfd, buf, MAX_SIZE-1, 0); if(ret == 0){ removefd(epollfd, sockfd); printf(\"foreiner closed the connection\\n\"); break; }else if(ret \u003c 0){ if(errno == EAGAIN){ // reset_oneshot(epollfd ,sockfd); printf(\"read later\\n\"); break; } }else{ printf(\"get connection:\\n\"); //休眠5s模拟数据处理过程 accept_request(epollfd, sockfd, buf); sleep(5); break; } } } //命令行参数指定IP和端口 int main(int argc, char *argv[]){ if(argc \u003c 2){ printf(\"at least 2 arguments: file port, but you give %d\\n\", argc); return 1; } int port = atoi(argv[1]); int lfd, cfd, ret; struct sockaddr_in serv_addr, clie_addr; lfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字 assert(lfd \u003e= 0); /*初始化服务器端的套接字地址*/ serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(port); serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); //端口复用 此处没有卵用 int opt = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, \u0026opt, sizeof(opt)); ret = bind(lfd, (struct sockaddr *)\u0026serv_addr, sizeof(serv_addr) ); assert(ret != -1); ret = listen(lfd, 128); //最大同时连接数 assert(ret != -1); epoll_event events[MAX_SIZE]; //返回的数组上限 int epollfd = epoll_create(10); assert(epollfd != -1); //注意监听的套接字不能设置为oneshot addfd(epollfd, lfd, false); //挂上红黑树监听 while(1){ ret = epoll_wait(epollfd, events, MAX_SIZE, -1); //永远不超时 if(ret \u003c 0){ printf(\"epoll failure\\n\"); break; } for(int i = 0; i \u003c ret; i++){ //循环处理有响应的事件 int sockfd = events[i].data.fd; if(sockfd == lfd){ //如果是监听事件则建立新的连接 socklen_t clie_addr_len; //套接字长度 clie_addr_len = sizeof(clie_addr); cfd = accept(lfd, (struct sockaddr*)\u0026clie_addr, \u0026clie_addr_len ); assert(cfd \u003e= 0); //注册为oneshot事件 addfd(epollfd, cfd, false); //刚刚这里加入的事件加错了 }else if(events[i].events \u0026 EPOLLIN){ pthread_t tid; fds fds_for_new_worker; fds_for_new_worker.epollfd = epollfd; fds_for_new_worker.sockfd = sockfd; //新启动一个线程为sockfd服务 pthread_create(\u0026tid, NULL, worker, (void*)\u0026fds_for_new_worker); // pthread_detach(tid); //线程分离 } } } close(lfd); return 0; } 线程中调用fork函数 pthread_atfork函数确保fork调用后父进程和子进程都拥有一个清楚的锁状态。每个线程都可以独立的设置信号掩码。\nwaitpid回收子进程 #include #include #include #include #include #include void sigchild_handler(int sig){ //在执行SIGCHLD信号期间 可能有多个SIGCHLD到达，但是未决信号集只记录一次。 //所以需要调用while循环回收再退出 while(waitpid(-1, NULL, WNOHANG) \u003e 0){ puts(\"回收成功\"); } return; } int main(){ pid_t pid; int n = 5, i; signal(SIGCHLD, sigchild_handler); for(i = 0; i \u003c n; i++){ pid = fork(); if(pid \u003c 0){ perror(\"fork error\"); exit(1); }else if(pid == 0) break; //子进程 直接退出 } if(i \u003c n){ //子进程 sleep(i); printf(\"I am %dth child.\\n\", i); }else{ while(1){ //父进程不退出 sleep(1); printf(\"I am parent %u\\n\", getpid()); } } return 0; } 自旋锁 线程同步的一种方式。使用自旋锁的线程会反复检查锁变量是否可用。自旋锁不会让出CPU，一种忙等待状态。死循环等待锁被释放。自旋锁避免了进程或线程上下文的开销。自旋锁不适合在单CPU中使用。\n#include #include #include #include const int N = 1e7; int num = 0; pthread_spinlock_t spin_lock; void *producer(void *){ int times = N; while(times--){ pthread_spin_lock(\u0026spin_lock); ++num; pthread_spin_unlock(\u0026spin_lock); } } void *comsumer(void*){ int times = N; while(times--){ pthread_spin_lock(\u0026spin_lock); --num; pthread_spin_unlock(\u0026spin_lock); } } int main(){ pthread_spin_init(\u0026spin_lock, 0); pthread_t th1, th2; pthread_create(\u0026th1, NULL, \u0026producer, NULL); pthread_create(\u0026th2, NULL, \u0026comsumer, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); printf(\"num = %d\\n\", num); return 0; } 条件变量 条件变量本身不是锁，但它可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个汇合的场所。\npthread_cond_wait(\u0026cond, \u0026mutex) 1. 阻塞等待该条件变量直到满足 2.释放已经掌握的互斥锁 3.满足条件后重新拿锁 #include #include #include #include const int MAX_BUF = 100; int num = 0; pthread_cond_t cond = PTHREAD_COND_INITIALIZER; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; void *producer(void *){ while(true){ pthread_mutex_lock(\u0026mutex); while(num \u003e= MAX_BUF){ //由于阻塞解除时，只有一个物品可用 但是却有多个线程解除阻塞 所以需要循环检测一次 //满了 等待消费者消费 pthread_cond_wait(\u0026cond, \u0026mutex); printf(\"缓冲区满了 等待消费者消费\\n\"); } //生产一个物品 ++num; printf(\"生产一个产品，当前产品数量为：%d\\n\", num); sleep(1); pthread_mutex_unlock(\u0026mutex); //通知消费者可消费了 pthread_cond_signal(\u0026cond); printf(\"通知消费者...\\n\"); sleep(1); } } void *comsumer(void*){ while(true){ pthread_mutex_lock(\u0026mutex); while(num \u003c= 0){ //缓冲区为空 等待生产者生产 pthread_cond_wait(\u0026cond, \u0026mutex); printf(\"缓冲区空了 等待生产者生产\\n\"); } //生产一个物品 --num; printf(\"消费一个产品，当前产品数量为：%d\\n\", num); sleep(1); pthread_mutex_unlock(\u0026mutex); //通知消费者可消费了 pthread_cond_signal(\u0026cond); printf(\"通知生产者...\\n\"); } } int main(){ pthread_t th1, th2; pthread_create(\u0026th1, NULL, \u0026producer, NULL); pthread_create(\u0026th2, NULL, \u0026comsumer, NULL); pthread_join(th1, NULL); pthread_join(th2, NULL); printf(\"num = %d\\n\", num); return 0; } ",
  "wordCount" : "6932",
  "inLanguage": "zh",
  "image": "https://i.postimg.cc/7hwBy7VS/calcr.png","datePublished": "2024-09-14T21:59:02+08:00",
  "dateModified": "2024-09-14T21:59:02+08:00",
  "author":{
    "@type": "Person",
    "name": "steamdk"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://steamdk.github.io/posts/006%E9%A1%B9%E7%9B%AE/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "项目介绍",
    "logo": {
      "@type": "ImageObject",
      "url": "https://steamdk.github.io/favicon.svg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://steamdk.github.io/" accesskey="h" title="项目介绍 (Alt + H)">项目介绍</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://steamdk.github.io/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      006项目
    </h1>
    <div class="post-meta"><span title='2024-09-14 21:59:02 +0800 CST'>2024-09-14</span>&nbsp;·&nbsp;14 分钟&nbsp;·&nbsp;steamdk

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#webbench" aria-label="webbench">webbench</a></li>
                <li>
                    <a href="#github" aria-label="github">github</a></li>
                <li>
                    <a href="#%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0" aria-label="回调函数">回调函数</a></li>
                <li>
                    <a href="#%e4%bf%a1%e5%8f%b7%e5%87%bd%e6%95%b0" aria-label="信号函数">信号函数</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b" aria-label="创建线程">创建线程</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%a4%9a%e4%b8%aa%e5%ad%90%e7%ba%bf%e7%a8%8b" aria-label="创建多个子线程">创建多个子线程</a></li>
                <li>
                    <a href="#mysql%e4%bd%bf%e7%94%a8" aria-label="mysql使用">mysql使用</a></li>
                <li>
                    <a href="#%e6%8c%87%e9%92%88%e5%92%8c%e6%95%b0%e7%bb%84" aria-label="指针和数组">指针和数组</a></li>
                <li>
                    <a href="#cgi%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="CGI服务器">CGI服务器</a></li>
                <li>
                    <a href="#epolloneshot%e4%ba%8b%e4%bb%b6" aria-label="EPOLLONESHOT事件">EPOLLONESHOT事件</a></li>
                <li>
                    <a href="#%e4%bf%a1%e5%8f%b7%e5%b1%8f%e8%94%bd%e5%ad%97" aria-label="信号屏蔽字">信号屏蔽字</a></li>
                <li>
                    <a href="#sigaction%e4%bf%a1%e5%8f%b7%e6%8d%95%e6%8d%89%e5%87%bd%e6%95%b0" aria-label="sigaction信号捕捉函数">sigaction信号捕捉函数</a></li>
                <li>
                    <a href="#%e7%bb%9f%e4%b8%80%e4%ba%8b%e4%bb%b6%e6%ba%90" aria-label="统一事件源">统一事件源</a></li>
                <li>
                    <a href="#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f" aria-label="单例模式">单例模式</a></li>
                <li>
                    <a href="#%e5%bd%93%e5%89%8d%e6%97%b6%e9%97%b4" aria-label="当前时间">当前时间</a></li>
                <li>
                    <a href="#%e5%88%9d%e9%98%b6%e6%97%a5%e5%bf%97%e7%b3%bb%e7%bb%9f" aria-label="初阶日志系统">初阶日志系统</a></li>
                <li>
                    <a href="#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f-1" aria-label="单例模式">单例模式</a></li>
                <li>
                    <a href="#%e4%b8%bb%e7%ba%bf%e7%a8%8b%e6%b5%8b%e8%af%95" aria-label="主线程测试">主线程测试</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e5%a0%86" aria-label="时间堆">时间堆</a></li>
                <li>
                    <a href="#exec%e5%87%bd%e6%95%b0%e6%97%8f" aria-label="exec函数族">exec函数族</a></li>
                <li>
                    <a href="#%e7%ae%a1%e9%81%93" aria-label="管道">管道</a></li>
                <li>
                    <a href="#cgi%e4%bd%bf%e7%94%a8%e7%ae%a1%e9%81%93%e5%92%8cexec%e5%ae%9e%e7%8e%b0" aria-label="CGI使用管道和exec实现">CGI使用管道和exec实现</a></li>
                <li>
                    <a href="#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="多线程服务器">多线程服务器</a></li>
                <li>
                    <a href="#%e5%a4%84%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af%e6%b3%a8%e5%86%8c%e4%bf%a1%e6%81%af%e7%9a%84cgi" aria-label="处理客户端注册信息的cgi">处理客户端注册信息的cgi</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e4%b8%ad%e8%b0%83%e7%94%a8fork%e5%87%bd%e6%95%b0" aria-label="线程中调用fork函数">线程中调用fork函数</a></li>
                <li>
                    <a href="#waitpid%e5%9b%9e%e6%94%b6%e5%ad%90%e8%bf%9b%e7%a8%8b" aria-label="waitpid回收子进程">waitpid回收子进程</a></li>
                <li>
                    <a href="#%e8%87%aa%e6%97%8b%e9%94%81" aria-label="自旋锁">自旋锁</a></li>
                <li>
                    <a href="#%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f" aria-label="条件变量">条件变量</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="webbench">webbench<a hidden class="anchor" aria-hidden="true" href="#webbench">#</a></h2>
<p>测压软件 最高并发3W</p>
<p>webbench做测试时自身也会消耗CPU和内存资源，为了测试准确，需要将webbench安装在别的服务器上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">tar -xzvf webbench-1.5.tar.gz
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> webbench-1.5
</span></span><span class="line"><span class="cl">apt-get install ctags
</span></span><span class="line"><span class="cl">make <span class="o">&amp;&amp;</span> make install
</span></span></code></pre></div><p>测试</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">webbench -c <span class="m">1000</span> -t <span class="m">5</span> http://127.0.0.1:9999/index.html //1000个客户端 5秒钟时间
</span></span></code></pre></div><h2 id="github">github<a hidden class="anchor" aria-hidden="true" href="#github">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">git clone https://github.com/SYaoJun/WebServer.git //把仓库中的内容拷贝到linux系统中
</span></span></code></pre></div><h2 id="回调函数">回调函数<a hidden class="anchor" aria-hidden="true" href="#回调函数">#</a></h2>
<p><strong>函数指针</strong>本身是指针变量，指向某个函数的入口地址。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">step</span><span class="p">)(</span><span class="kt">void</span><span class="p">)){</span> <span class="c1">//回调函数的传参是声明的格式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">step</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="nf">step</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cb</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>  <span class="c1">//回调函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;记秒到时&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">run</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">gcc</span> <span class="n">cb</span><span class="p">.</span><span class="n">c</span> <span class="n">main</span><span class="p">.</span><span class="n">c</span>
</span></span></code></pre></div><h2 id="信号函数">信号函数<a hidden class="anchor" aria-hidden="true" href="#信号函数">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">raise</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">)</span> <span class="c1">//自己给自己进程发送信号 11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">abort</span><span class="p">()</span> <span class="c1">//终止当前进程
</span></span></span></code></pre></div><p>测试1s打印多少个数</p>
<p>alarm函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">alarm</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//计时1s 到时后内核发送一个sigalarm信号终止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>setitimer函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">my_alarm</span><span class="p">(</span><span class="kt">int</span> <span class="n">sec</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">itimerval</span> <span class="n">it</span><span class="p">,</span> <span class="n">oldit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sec</span><span class="p">;</span> <span class="c1">//定时长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//微秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">it</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//周期定时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">it</span><span class="p">.</span><span class="n">it_interval</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">setitimer</span><span class="p">(</span><span class="n">ITIMER_REAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldit</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;setitimer error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">oldit</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">my_alarm</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//计时1s 到时后内核发送一个sigalarm信号终止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="创建线程">创建线程<a hidden class="anchor" aria-hidden="true" href="#创建线程">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span> <span class="c1">//必须为这种类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;in thread : thread id: %lu, process id: %u</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">pthread_self</span><span class="p">(),</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//创建线程 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pthread_t</span> <span class="n">tid</span><span class="p">;</span> <span class="c1">//重命名的unsigned long 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//创建线程API pthread_create(arg1, agr2, arg3, arg4) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//arg1: 传入的线程tid地址 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//arg2: 线程属性 通常设置为NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//arg3: 线程执行的任务 函数指针 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//arg4: 参数3传递的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;in main 1 : thread id: %lu, process id: %u</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">pthread_self</span><span class="p">(),</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;pthread_create error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//主线程 等待子线程执行完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;in main 2 : thread id: %lu, process id: %u</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">pthread_self</span><span class="p">(),</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="创建多个子线程">创建多个子线程<a hidden class="anchor" aria-hidden="true" href="#创建多个子线程">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span> <span class="c1">//必须为这种类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%dth thread id: %lu, process id: %u</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nf">pthread_self</span><span class="p">(),</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//创建线程 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pthread_t</span> <span class="n">tid</span><span class="p">;</span> <span class="c1">//重命名的unsigned long 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//创建线程API pthread_create(arg1, agr2, arg3, arg4) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//arg1: 传入的线程tid地址 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//arg2: 线程属性 通常设置为NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//arg3: 线程执行的任务 函数指针 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//arg4: 参数3传递的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">i</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s pthread_create error&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_detach</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">//主线程 等待子线程执行完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="mysql使用">mysql使用<a hidden class="anchor" aria-hidden="true" href="#mysql使用">#</a></h2>
<p>mysql在linux环境下结合C语言的使用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo apt-get install mysql-client mysql-server //先安装mysql
</span></span><span class="line"><span class="cl">sudo apt-get install libmysql++-dev //安装库
</span></span></code></pre></div><p>先启动mysql库 设置好密码 然后使用c程序连接</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mysql/mysql.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="n">MYSQL</span> <span class="n">mysql</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">MYSQL_RES</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">MYSQL_ROW</span> <span class="n">row</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">char</span> <span class="o">*</span><span class="n">query</span> <span class="o">=</span> <span class="s">&#34;select * from people;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mysql_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">);</span> <span class="c1">//初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nf">mysql_real_connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">,</span><span class="s">&#34;localhost&#34;</span><span class="p">,</span><span class="s">&#34;root&#34;</span><span class="p">,</span><span class="s">&#34;password&#34;</span><span class="p">,</span><span class="s">&#34;yaojun&#34;</span><span class="p">,</span><span class="mi">3306</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">0</span><span class="p">)){</span> <span class="c1">//连接数据库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Error in connecting&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="nf">mysql_query</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">,</span><span class="n">query</span><span class="p">)){</span> <span class="c1">//查询数据库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Error in querying&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">res</span> <span class="o">=</span> <span class="nf">mysql_store_result</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="nf">mysql_fetch_row</span><span class="p">(</span><span class="n">res</span><span class="p">)){</span> <span class="c1">//读取数据库中的一行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="nf">mysql_num_fields</span><span class="p">(</span><span class="n">res</span><span class="p">);</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        	<span class="nf">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span><span class="s">&#34;%s &#34;</span><span class="p">,</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mysql_free_result</span><span class="p">(</span><span class="n">res</span><span class="p">);</span> <span class="c1">//释放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">mysql_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysql</span><span class="p">);</span> <span class="c1">//关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>编译的命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc sql.c -lmysqlclient //生成a.out文件 执行
</span></span></code></pre></div><h2 id="指针和数组">指针和数组<a hidden class="anchor" aria-hidden="true" href="#指针和数组">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">str</span><span class="p">[]</span><span class="o">=</span><span class="s">&#34;hello&#34;</span><span class="p">;</span> <span class="c1">//字符串含\0   6字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">char</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span><span class="s">&#34;hello&#34;</span><span class="p">;</span> <span class="c1">//指针64位机   8字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="cgi服务器">CGI服务器<a hidden class="anchor" aria-hidden="true" href="#cgi服务器">#</a></h2>
<p>原理：输出到某个文件描述符上的内容直接发送到客户端连接对应的socket上，此处我们模拟了把服务器端输出到标准输出的内容，直接发送给客户端。</p>
<p>测试</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">telnet</span> <span class="mf">127.0.0.1</span> <span class="mi">6666</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//命令行参数指定IP和端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;at least 3 arguments: file ip port, but you give %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">lfd</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">,</span> <span class="n">clie_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">lfd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//创建套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">lfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//端口复用 此处没有卵用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">opt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">setsockopt</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">bind</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">listen</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="c1">//最大同时连接数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">socklen_t</span> <span class="n">clie_addr_len</span><span class="p">;</span> <span class="c1">//套接字长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">clie_addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clie_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cfd</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clie_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clie_addr_len</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">cfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;accept error: %d&#34;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">dup</span><span class="p">(</span><span class="n">cfd</span><span class="p">);</span> <span class="c1">//创建一个新的文件描述符 该文件描述符和原文件描述符指向相同的文件 管道和网络连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;good night! daisy!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">cfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">close</span><span class="p">(</span><span class="n">lfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="epolloneshot事件">EPOLLONESHOT事件<a hidden class="anchor" aria-hidden="true" href="#epolloneshot事件">#</a></h2>
<p>一个socket上的某个事件被触发多次，可能产生2个不同的线程处理同一个socket。我们期望的是一个socket在任一时刻都只被一个线程处理。对于注册了EPOLLONESHOT事件的文件描述符，操做系统最多触发其上注册的一个可读可写或者异常事件一次。注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，应立即重置这个socket上的EPOLLONESHOT事件。</p>
<p>监听socket不应设置为EPOLLONESHOT。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SIZE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//自定义的结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">fds</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">epollfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//设置文件描述符为非阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setnonblocking</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">old_option</span> <span class="o">=</span> <span class="nf">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">new_option</span> <span class="o">=</span> <span class="n">old_option</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">new_option</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加到epoll内核事件表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">addfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">oneshot</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">oneshot</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLONESHOT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span> <span class="c1">//挂到红黑树上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">setnonblocking</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span> <span class="c1">//设置非阻塞 主要用在读写上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//重置EPOLLONESHOT事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">reset_oneshot</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span> <span class="o">|</span> <span class="n">EPOLLONESHOT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span> <span class="c1">//修改注册事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//工作线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">worker</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="p">((</span><span class="n">fds</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">epollfd</span> <span class="o">=</span> <span class="p">((</span><span class="n">fds</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">epollfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;start new thread to receive data on fd: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">MAX_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//循环读取sockfd上的数据 直到收到EAGAIN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">recv</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAX_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;foreiner closed the connection</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">reset_oneshot</span><span class="p">(</span><span class="n">epollfd</span> <span class="p">,</span><span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;read later</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;get connection: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//休眠5s模拟数据处理过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;end thread receiving data on fd: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//命令行参数指定IP和端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;at least 3 arguments: file ip port, but you give %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">lfd</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">,</span> <span class="n">clie_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">lfd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//创建套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">lfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//端口复用 此处没有卵用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">opt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">setsockopt</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">bind</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">listen</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="c1">//最大同时连接数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">];</span> <span class="c1">//返回的数组上限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">epollfd</span> <span class="o">=</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">epollfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//注意监听的套接字不能设置为oneshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addfd</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">lfd</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span> <span class="c1">//挂上红黑树监听
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;addfd</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_SIZE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//永远不超时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;epoll failure</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">//循环处理有响应的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">sockfd</span> <span class="o">==</span> <span class="n">lfd</span><span class="p">){</span> <span class="c1">//如果是监听事件则建立新的连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;lfd</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">socklen_t</span> <span class="n">clie_addr_len</span><span class="p">;</span> <span class="c1">//套接字长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">clie_addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clie_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">cfd</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clie_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clie_addr_len</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">assert</span><span class="p">(</span><span class="n">cfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//注册为oneshot事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">addfd</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span> <span class="c1">//刚刚这里加入的事件加错了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="kt">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">fds</span> <span class="n">fds_for_new_worker</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">fds_for_new_worker</span><span class="p">.</span><span class="n">epollfd</span> <span class="o">=</span> <span class="n">epollfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">fds_for_new_worker</span><span class="p">.</span><span class="n">sockfd</span> <span class="o">=</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//新启动一个线程为sockfd服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fds_for_new_worker</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// pthread_detach(tid); //线程分离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">close</span><span class="p">(</span><span class="n">lfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="信号屏蔽字">信号屏蔽字<a hidden class="anchor" aria-hidden="true" href="#信号屏蔽字">#</a></h2>
<p>主要函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">sigaddset</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">sigprocmask</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">sigpending</span><span class="p">()</span>
</span></span></code></pre></div><p>使用kill发送信号</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">kill</span> <span class="o">-</span><span class="mi">6</span> <span class="n">PID</span>
</span></span></code></pre></div><p>测试程序</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">sigset_t</span><span class="o">*</span> <span class="n">ped</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="nf">sigismember</span><span class="p">(</span><span class="n">ped</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">putchar</span><span class="p">(</span><span class="sc">&#39;1&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="nf">putchar</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">sigset_t</span> <span class="n">myset</span><span class="p">,</span> <span class="n">oldset</span><span class="p">,</span> <span class="n">ped</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置自定义信号集
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myset</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myset</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myset</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myset</span><span class="p">,</span> <span class="n">SIGABRT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置信号屏蔽字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sigpending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ped</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">print</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ped</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="sigaction信号捕捉函数">sigaction信号捕捉函数<a hidden class="anchor" aria-hidden="true" href="#sigaction信号捕捉函数">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">docatch</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d signal has been catched!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">signo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">act</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">docatch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGSEGV</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGQUIT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//默认属性 在信号函数处理期间 本信号再次到达默认屏蔽
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sigaction</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="统一事件源">统一事件源<a hidden class="anchor" aria-hidden="true" href="#统一事件源">#</a></h2>
<p>把信号事件的处理放到epoll监听事件中去处理，统一了事件源。当调用信号处理函数时，信号处理函数通过管道将信息传达给epoll上的读端监听事件，再在主循环中处理事件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SIZE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//自定义的结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">fds</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">epollfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//设置文件描述符为非阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setnonblocking</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">old_option</span> <span class="o">=</span> <span class="nf">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">new_option</span> <span class="o">=</span> <span class="n">old_option</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">new_option</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加到epoll内核事件表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">addfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">oneshot</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">oneshot</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLONESHOT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span> <span class="c1">//挂到红黑树上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">setnonblocking</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span> <span class="c1">//设置非阻塞 主要用在读写上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//信号处理函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">sig_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">save_errno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span> <span class="c1">//我猜想这里重新定义变量的原因在于传的是指针 同时为了保证可重入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">send</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//pipefd[1]是非阻塞的如果发不出去直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">errno</span> <span class="o">=</span> <span class="n">save_errno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//设置信号处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">addsig</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sa</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sa</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_RESTART</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sigaddset(&amp;sa.sa_mask, SIGSEGV);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nf">sigaction</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//注册监听的信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//命令行参数指定IP和端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;at least 3 arguments: file ip port, but you give %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">lfd</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">,</span> <span class="n">clie_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">lfd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//创建套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">lfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//端口复用 此处没有卵用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">opt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">setsockopt</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">//忽略SIGPIPE信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">bind</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">listen</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="c1">//最大同时连接数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">];</span> <span class="c1">//返回的数组上限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">epollfd</span> <span class="o">=</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">epollfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//注意监听的套接字不能设置为oneshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addfd</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">lfd</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span> <span class="c1">//挂上红黑树监听
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="cm">/*使用socketpair创建全双工的管道*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">socketpair</span><span class="p">(</span><span class="n">PF_UNIX</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pipefd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">setnonblocking</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">//把写入的管道端置为非阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addfd</span><span class="p">(</span> <span class="n">epollfd</span><span class="p">,</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">false</span><span class="p">);</span> <span class="c1">//设置为oneshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*设置一些信号的处理函数*/</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addsig</span><span class="p">(</span><span class="n">SIGHUP</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addsig</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addsig</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addsig</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addsig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">stop_server</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stop_server</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;epoll_wait...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_SIZE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//永远不超时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">((</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EINTR</span><span class="p">)){</span> <span class="c1">//这里要设置 被系统调用打断的不算失败 errno不是ret
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;epoll failure&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">//循环处理有响应的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">sockfd</span> <span class="o">==</span> <span class="n">lfd</span><span class="p">){</span> <span class="c1">//如果是监听事件则建立新的连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                
</span></span><span class="line"><span class="cl">                <span class="kt">socklen_t</span> <span class="n">clie_addr_len</span><span class="p">;</span> <span class="c1">//套接字长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">clie_addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clie_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">cfd</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clie_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clie_addr_len</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">assert</span><span class="p">(</span><span class="n">cfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//注册为oneshot事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">addfd</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="cm">/*如果就绪的文件描述符是pipefd[0],就处理信号*/</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">sockfd</span> <span class="o">==</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">                <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nf">recv</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">//可能管道有多个信号满足 每次读出一个字符进行处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                        <span class="k">switch</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                            <span class="k">case</span> <span class="nl">SIGSEGV</span><span class="p">:</span> <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;段错误信号已处理，收到请回答！&#34;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                            <span class="k">case</span> <span class="nl">SIGCHLD</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                            <span class="k">case</span> <span class="nl">SIGHUP</span><span class="p">:</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                            <span class="k">case</span> <span class="nl">SIGTERM</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                            <span class="k">case</span> <span class="nl">SIGINT</span><span class="p">:</span> <span class="n">stop_server</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span><span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;close fds</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">lfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="单例模式">单例模式<a hidden class="anchor" aria-hidden="true" href="#单例模式">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">Singleton</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nl">private</span><span class="p">:</span> <span class="c1">//无法调用构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Singleton</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Singleton</span><span class="p">(</span><span class="k">const</span> <span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="nf">getInstance</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">Singleton</span><span class="o">*</span> <span class="n">m_instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="n">m_instance</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//懒汉式 单线程版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="nf">getInstance</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">m_instance</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">m_instance</span> <span class="o">=</span> <span class="n">new</span> <span class="nf">Singleton</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">m_instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//多线程版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Singleton</span><span class="o">*</span> <span class="n">Singleton</span><span class="o">::</span><span class="nf">getInstance</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">LOCK</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">m_instance</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">m_instance</span> <span class="o">=</span> <span class="n">new</span> <span class="nf">Singleton</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">m_instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="当前时间">当前时间<a hidden class="anchor" aria-hidden="true" href="#当前时间">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">tm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">time_string</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ctime_r</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="p">,</span> <span class="n">time_string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">time_string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="初阶日志系统">初阶日志系统<a hidden class="anchor" aria-hidden="true" href="#初阶日志系统">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">class</span> <span class="n">Logger</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nl">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">Logger</span><span class="o">*</span> <span class="nf">get_instance</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">Logger</span><span class="o">*</span> <span class="n">log</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="n">mutex</span> <span class="n">log_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="kt">void</span> <span class="nf">write_log</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="kt">void</span> <span class="nf">create_file</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nl">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Logger</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Logger</span><span class="p">(</span><span class="k">const</span> <span class="n">Logger</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">~</span><span class="nf">Logger</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Logger</span><span class="o">*</span> <span class="n">Logger</span><span class="o">::</span><span class="n">log</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mutex</span> <span class="n">Logger</span><span class="o">::</span><span class="n">log_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Logger</span><span class="o">::</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Logger</span><span class="o">::</span><span class="nf">Logger</span><span class="p">(){};</span>
</span></span><span class="line"><span class="cl"><span class="n">Logger</span><span class="o">::~</span><span class="nf">Logger</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">log</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">delete</span> <span class="n">log</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">log</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">Logger</span><span class="o">*</span> <span class="n">Logger</span><span class="o">::</span><span class="nf">get_instance</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">log</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">log_mutex</span><span class="p">.</span><span class="nf">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">log</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">log</span> <span class="o">=</span> <span class="n">new</span> <span class="nf">Logger</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">log_mutex</span><span class="p">.</span><span class="nf">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">log</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Logger</span><span class="o">::</span><span class="nf">create_file</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;logger.txt&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="o">|</span><span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_TRUNC</span><span class="p">,</span> <span class="mi">777</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Logger</span><span class="o">::</span><span class="nf">write_log</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">log_mutex</span><span class="p">.</span><span class="nf">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">log_mutex</span><span class="p">.</span><span class="nf">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="单例模式-1">单例模式<a hidden class="anchor" aria-hidden="true" href="#单例模式-1">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">//C++11 atomic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Logger</span><span class="o">*&gt;</span> <span class="n">Logger</span><span class="o">::</span><span class="n">log</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">Logger</span><span class="o">::</span><span class="n">log_mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Logger</span><span class="o">*</span> <span class="n">Logger</span><span class="o">::</span><span class="nf">get_instance</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Logger</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">log</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="nf">atomic_thread_fence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span> <span class="c1">//获取内存fence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="nf">lock</span><span class="p">(</span><span class="n">log_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span> <span class="o">=</span> <span class="n">log</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">NUll</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="nf">atomic_thread_fence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">//释放内存fence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">log</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="主线程测试">主线程测试<a hidden class="anchor" aria-hidden="true" href="#主线程测试">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;logger.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&#34;thread id: %lu, process id: %u</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">pthread_self</span><span class="p">(),</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">Logger</span><span class="o">::</span><span class="n">log</span><span class="o">-&gt;</span><span class="nf">write_log</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">tid</span><span class="p">;</span> <span class="c1">//重命名的unsigned long 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Logger</span><span class="o">::</span><span class="n">log</span><span class="o">-&gt;</span><span class="nf">create_file</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// int t = i;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ret</span> <span class="o">=</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s pthread_create error&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_detach</span><span class="p">(</span><span class="n">tid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//主线程 等待子线程执行完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="时间堆">时间堆<a hidden class="anchor" aria-hidden="true" href="#时间堆">#</a></h2>
<p>把监听文件描述符加入后，就启动定时器。</p>
<h2 id="exec函数族">exec函数族<a hidden class="anchor" aria-hidden="true" href="#exec函数族">#</a></h2>
<p>在一个程序中运行另一个程序。当进程调用exec函数时，该进程的用户空间代码和数据完全被新程序替换。调用exec并不创建新进程，所以调用exec前后进程的ID并不改变。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;fork error!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">execlp</span><span class="p">(</span><span class="s">&#34;ls&#34;</span><span class="p">,</span> <span class="s">&#34;anythingok&#34;</span><span class="p">,</span> <span class="s">&#34;-l&#34;</span><span class="p">,</span> <span class="s">&#34;-a&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;parent over!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="管道">管道<a hidden class="anchor" aria-hidden="true" href="#管道">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pipe</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span> <span class="c1">//创建管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">//父进程 父写 fd[0]读 fd[1]写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span><span class="s">&#34;hello world</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">str</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">//子进程 子读 fd[1]关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//写到显示器上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="cgi使用管道和exec实现">CGI使用管道和exec实现<a hidden class="anchor" aria-hidden="true" href="#cgi使用管道和exec实现">#</a></h2>
<p>hello里面的输入和输出都被重定向了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">agrc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">bf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">bf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sprintf</span><span class="p">(</span><span class="n">bf</span><span class="p">,</span> <span class="s">&#34;Content-Type:text/html;</span><span class="se">\r\n\r\n</span><span class="s">hello world, 你好!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">bf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>主进程调用已经编译完毕的hello可执行文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cgi_input</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cgi_output</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*创建输入管道*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">pipe</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;pipe error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*创建输出管道*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">pipe</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;pipe error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*创建子进程*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;fork error!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">dup2</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/*将子进程的STDIN重定向到cgi_input[0]*/</span>
</span></span><span class="line"><span class="cl">        <span class="nf">dup2</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/*将子进程的STDOUT重定向到cgi_output[1]*/</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*关闭剩余的两端*/</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*执行exec文件 即cgi*/</span>
</span></span><span class="line"><span class="cl">        <span class="nf">execl</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="s">&#34;anythingok&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>  <span class="cm">/*父进程先给子进程发送数据 然后等待子进程执行完 再读数据*/</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*关闭不用的两个端口*/</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">=</span><span class="s">&#34;hello child process&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*父进程先写数据*/</span>
</span></span><span class="line"><span class="cl">        <span class="nf">write</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*父进程阻塞等待读入*/</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*关闭管道*/</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="多线程服务器">多线程服务器<a hidden class="anchor" aria-hidden="true" href="#多线程服务器">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;dirent.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SERV_PORT 9999
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MAXSIZE 2048
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">wait_child</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="nf">waitpid</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WNOHANG</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">createlistenfd</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//创建套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;socket error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化servaddr结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="n">SERV_PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//端口复用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">opt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">setsockopt</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//绑定端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="nf">bind</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;bind error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//设置监听上限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="nf">listen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ret</span><span class="o">==-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;listen error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">work</span><span class="p">(</span><span class="kt">int</span> <span class="n">cfd</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sscanf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#34;GET /%s&#34;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">mime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">strstr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#34;.html&#34;</span><span class="p">))</span> <span class="n">mime</span> <span class="o">=</span> <span class="s">&#34;text/html&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nf">strstr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#34;.jpg&#34;</span><span class="p">))</span> <span class="n">mime</span><span class="o">=</span><span class="s">&#34;image/jpeg&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//构建响应头 发给客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// printf(&#34;%s\n&#34;, filename);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">response</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sprintf</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s">&#34;HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s">Content-Type: %s</span><span class="se">\r\n\r\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">mime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//读取具体的文件内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">filefd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">filefd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;open error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">filefd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span> <span class="c1">//很奇怪 为什么睡几秒钟之后再打开就不会出错了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">filefd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">filefd</span><span class="p">,</span> <span class="n">response</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">response</span><span class="p">)</span><span class="o">-</span><span class="n">len</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">write</span><span class="p">(</span><span class="n">cfd</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">filefd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">lfd</span> <span class="o">=</span> <span class="nf">createlistenfd</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">clientaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">socklen_t</span> <span class="n">clientaddrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span> <span class="c1">//这是一个传出参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//accept接受连接请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">cfd</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clientaddrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">cfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;accept error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//创建子线程 主线程负责监听和回收子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;fork error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">cfd</span><span class="p">);</span> <span class="c1">//关闭接收文件描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">signal</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">wait_child</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">close</span><span class="p">(</span><span class="n">lfd</span><span class="p">);</span> <span class="c1">//关闭监听文件描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//打印客户端IP和port
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;client IP: %s, client port: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nf">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">            <span class="nf">ntohs</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">cfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">cfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// write(1, buf, n);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="nf">work</span><span class="p">(</span><span class="n">cfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="处理客户端注册信息的cgi">处理客户端注册信息的cgi<a hidden class="anchor" aria-hidden="true" href="#处理客户端注册信息的cgi">#</a></h2>
<ul>
<li>存在一些问题，每个网页好像没有传输完成，浏览器总是转圈。</li>
<li>需要结合上面hello程序查询数据库，hello程序的注册还没完善，只能做到查询。等以后有空再做吧。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_SIZE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">//自定义的结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">fds</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">epollfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//设置文件描述符为非阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setnonblocking</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">old_option</span> <span class="o">=</span> <span class="nf">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">new_option</span> <span class="o">=</span> <span class="n">old_option</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">new_option</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//添加到epoll内核事件表中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">addfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">oneshot</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">oneshot</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLONESHOT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span> <span class="c1">//挂到红黑树上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">setnonblocking</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span> <span class="c1">//设置非阻塞 主要用在读写上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//移除epoll事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">removefd</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//重置EPOLLONESHOT事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">reset_oneshot</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span> <span class="o">|</span> <span class="n">EPOLLONESHOT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span> <span class="c1">//修改注册事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">accept_request</span><span class="p">(</span><span class="kt">int</span> <span class="n">epollfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">method</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">filename</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">account</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">password</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">phone</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sscanf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#34;%s /%s&#34;</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">&#34;POST&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">&lt;</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;\r&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">12</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39;&amp;&#39;</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">account</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39;&amp;&#39;</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">password</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*2020.4.7成功解析出来账号和密码*/</span>
</span></span><span class="line"><span class="cl">        <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cgi_input</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cgi_output</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*创建输入管道*/</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="nf">pipe</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;pipe error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*创建输出管道*/</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="nf">pipe</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;pipe error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*创建子进程*/</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;fork error!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">            <span class="nf">dup2</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/*将子进程的STDIN重定向到cgi_input[0]*/</span>
</span></span><span class="line"><span class="cl">            <span class="nf">dup2</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/*将子进程的STDOUT重定向到cgi_output[1]*/</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*关闭剩余的两端*/</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*执行exec文件 即cgi*/</span>
</span></span><span class="line"><span class="cl">            <span class="nf">execl</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="s">&#34;anythingok&#34;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>  <span class="cm">/*父进程先给子进程发送数据 然后等待子进程执行完 再读数据*/</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*关闭不用的两个端口*/</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> 
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*父进程先写数据*/</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">account</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">write</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">account</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*父进程阻塞等待读入*/</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buff</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buff</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="nf">strlen</span><span class="p">(</span><span class="n">password</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;密码正确&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;密码错误&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">strcpy</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#34;register.html&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// int ret = write(STDOUT_FILENO, buf, n);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="cm">/*关闭管道*/</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">cgi_input</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">close</span><span class="p">(</span><span class="n">cgi_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">puts</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">mime</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nf">strstr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#34;.html&#34;</span><span class="p">))</span> <span class="nf">strcpy</span><span class="p">(</span><span class="n">mime</span><span class="p">,</span><span class="s">&#34;text/html&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nf">strstr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#34;.jpg&#34;</span><span class="p">))</span> <span class="nf">strcpy</span><span class="p">(</span><span class="n">mime</span><span class="p">,</span><span class="s">&#34;image/jpeg&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">response</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="o">+</span><span class="n">MAX_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sprintf</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s">&#34;HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s">Content-Type: %s</span><span class="se">\r\n\r\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">mime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">filefd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">filefd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;open error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">filefd</span><span class="p">,</span> <span class="n">response</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">response</span><span class="p">)</span><span class="o">-</span><span class="n">len</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">filefd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//工作线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">worker</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="p">((</span><span class="n">fds</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">epollfd</span> <span class="o">=</span> <span class="p">((</span><span class="n">fds</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">epollfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">MAX_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//循环读取sockfd上的数据 直到收到EAGAIN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="nf">recv</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAX_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">removefd</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;foreiner closed the connection</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// reset_oneshot(epollfd ,sockfd);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;read later</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;get connection:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//休眠5s模拟数据处理过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">accept_request</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">//命令行参数指定IP和端口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;at least 2 arguments: file port, but you give %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">lfd</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">serv_addr</span><span class="p">,</span> <span class="n">clie_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">lfd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//创建套接字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">lfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	 <span class="cm">/*初始化服务器端的套接字地址*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">serv_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//端口复用 此处没有卵用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">opt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">setsockopt</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">=</span> <span class="nf">bind</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">serv_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">serv_addr</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">listen</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="c1">//最大同时连接数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">];</span> <span class="c1">//返回的数组上限
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">epollfd</span> <span class="o">=</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">assert</span><span class="p">(</span><span class="n">epollfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//注意监听的套接字不能设置为oneshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">addfd</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">lfd</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span> <span class="c1">//挂上红黑树监听
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_SIZE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//永远不超时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;epoll failure</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">//循环处理有响应的事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">sockfd</span> <span class="o">==</span> <span class="n">lfd</span><span class="p">){</span> <span class="c1">//如果是监听事件则建立新的连接
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kt">socklen_t</span> <span class="n">clie_addr_len</span><span class="p">;</span> <span class="c1">//套接字长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">clie_addr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clie_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">cfd</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clie_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clie_addr_len</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="nf">assert</span><span class="p">(</span><span class="n">cfd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//注册为oneshot事件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">addfd</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span> <span class="c1">//刚刚这里加入的事件加错了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="kt">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">fds</span> <span class="n">fds_for_new_worker</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">fds_for_new_worker</span><span class="p">.</span><span class="n">epollfd</span> <span class="o">=</span> <span class="n">epollfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">fds_for_new_worker</span><span class="p">.</span><span class="n">sockfd</span> <span class="o">=</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//新启动一个线程为sockfd服务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fds_for_new_worker</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// pthread_detach(tid); //线程分离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">close</span><span class="p">(</span><span class="n">lfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="线程中调用fork函数">线程中调用fork函数<a hidden class="anchor" aria-hidden="true" href="#线程中调用fork函数">#</a></h2>
<p>pthread_atfork函数确保fork调用后父进程和子进程都拥有一个清楚的锁状态。每个线程都可以独立的设置信号掩码。</p>
<h2 id="waitpid回收子进程">waitpid回收子进程<a hidden class="anchor" aria-hidden="true" href="#waitpid回收子进程">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">sigchild_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//在执行SIGCHLD信号期间 可能有多个SIGCHLD到达，但是未决信号集只记录一次。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//所以需要调用while循环回收再退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="nf">waitpid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">WNOHANG</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">puts</span><span class="p">(</span><span class="s">&#34;回收成功&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">signal</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="n">sigchild_handler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;fork error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">//子进程 直接退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span> <span class="c1">//子进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">sleep</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;I am %dth child.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span> <span class="c1">//父进程不退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;I am parent %u</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="自旋锁">自旋锁<a hidden class="anchor" aria-hidden="true" href="#自旋锁">#</a></h2>
<p>线程同步的一种方式。使用自旋锁的线程会反复检查锁变量是否可用。自旋锁不会让出CPU，一种忙等待状态。死循环等待锁被释放。<strong>自旋锁避免了进程或线程上下文的开销</strong>。自旋锁不适合在单CPU中使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mf">1e7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_spinlock_t</span> <span class="n">spin_lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">times</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spin_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spin_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">comsumer</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">times</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">times</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spin_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">--</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spin_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_spin_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spin_lock</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">producer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comsumer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_join</span><span class="p">(</span><span class="n">th1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_join</span><span class="p">(</span><span class="n">th2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;num =  %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="条件变量">条件变量<a hidden class="anchor" aria-hidden="true" href="#条件变量">#</a></h2>
<p>条件变量本身不是锁，但它可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个汇合的场所。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mf">1.</span> <span class="err">阻塞等待该条件变量直到满足</span> <span class="mf">2.</span><span class="err">释放已经掌握的互斥锁</span> <span class="mf">3.</span><span class="err">满足条件后重新拿锁</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_BUF</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_cond_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">pthread_mutex_t</span> <span class="n">mutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">       <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="k">while</span><span class="p">(</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">MAX_BUF</span><span class="p">){</span> <span class="c1">//由于阻塞解除时，只有一个物品可用 但是却有多个线程解除阻塞 所以需要循环检测一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="c1">//满了 等待消费者消费
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">           <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;缓冲区满了 等待消费者消费</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="c1">//生产一个物品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">++</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;生产一个产品，当前产品数量为：%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//通知消费者可消费了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;通知消费者...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">comsumer</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">       <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="k">while</span><span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">           <span class="c1">//缓冲区为空 等待生产者生产
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">           <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;缓冲区空了 等待生产者生产</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="c1">//生产一个物品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="o">--</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;消费一个产品，当前产品数量为：%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//通知消费者可消费了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;通知生产者...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">producer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comsumer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_join</span><span class="p">(</span><span class="n">th1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_join</span><span class="p">(</span><span class="n">th2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;num =  %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://steamdk.github.io/tags/cpp/">Cpp</a></li>
      <li><a href="https://steamdk.github.io/tags/%E5%9F%BA%E7%A1%80/">基础</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://steamdk.github.io/posts/%E9%9D%A2%E7%BB%8F0306cvte/">
    <span class="title">« 上一页</span>
    <br>
    <span>面经0306CVTE</span>
  </a>
  <a class="next" href="https://steamdk.github.io/posts/005%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
    <span class="title">下一页 »</span>
    <br>
    <span>005数据结构</span>
  </a>
</nav>

  </footer><div id="tw-comment"></div>
<script>
    
    const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "light" : "dark";
    const setGiscusTheme = () => {
        const sendMessage = (message) => {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (iframe) {
                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');
            }
        }
        sendMessage({setConfig: {theme: getStoredTheme()}})
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "steamdk\/steamdk.github.io",
            "data-repo-id": "R_kgDONN_Y2g",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDONN_Y2s4CkVh9",
            "data-mapping": "pathname",
            "data-strict": "0",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "zh-CN",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
                ([key, value]) => giscusScript.setAttribute(key, value));
        document.querySelector("#tw-comment").appendChild(giscusScript);

        
        const themeSwitcher = document.querySelector("#theme-toggle");
        if (themeSwitcher) {
            themeSwitcher.addEventListener("click", setGiscusTheme);
        }
        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");
        if (themeFloatSwitcher) {
            themeFloatSwitcher.addEventListener("click", setGiscusTheme);
        }
    });
</script>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://github.com/steamdk/steamdk.github.io">©2024 项目介绍</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>


<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js"
  integrity="sha512-9ZKhgaFdKlsELap/dGw3Iaz5Bj+Las0XXZiRKYZaN9QArg6FtkD5rULNmNH4rTCTFxjPiBGr3MX8smRADRorDA=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
  var OSName = "unknown";
  var navApp = navigator.userAgent.toLowerCase();
  switch (true) {
    case (navApp.indexOf("win") != -1):
      OSName = "windows";
      break;
    case (navApp.indexOf("mac") != -1):
      OSName = "apple";
      break;
    case (navApp.indexOf("linux") != -1):
      OSName = "linux";
      break;
    case (navApp.indexOf("x11") != -1):
      OSName = "unix";
      break;
  }

  const images = Array.from(document.querySelectorAll(".post-content img"));
  images.forEach(img => {
    mediumZoom(img, {
      margin: 1,    
      
      container: null,  
      template: null,  
      
    });
  });

  if (OSName == "windows") {
    document.body.className += ' win11'
  }
</script>






<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
