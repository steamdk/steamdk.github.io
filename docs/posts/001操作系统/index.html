<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>001操作系统 | 项目介绍</title>
<meta name="keywords" content="cpp, 基础">
<meta name="description" content="阻塞IO和非阻塞IO

阻塞的文件描述符为阻塞IO
非阻塞的文件描述符为非阻塞IO

同步IO和异步IO

同步IO向应用程序通知的是IO就绪事件。要求用户代码自行执行读写操作，将数据从内核缓冲区读入用户缓冲区。
异步IO向应用程序通知的是IO完成事件 。由内核来执行IO读写操作。在linux环境下，aio.h头文件定义的函数提供了对异步IO的支持。

事件处理模式

reactor 同步IO模型通常用于实现reactor模式。要求主线程只负责监听文件描述符是否有事件发生，有的话就立即将该事件通知工作线程。
proactor 异步IO模型通常用于实现proactor模式。也可以用同步IO模拟出proactor模式。proactor将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。

Reactor模式的工作流程

主线程往epoll内核事件表中注册socket上的就绪事件。
主线程调用epoll_wait等待socket上有数据可读。
当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列。
睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。
主线程调用epoll_wait等待socket可写。
当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。
睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。

并发模式


半同步半异步模式：同步线程用于处理客户逻辑，异步线程用于处理IO事件。异步线程监听到客户请求后，就将其封装成请求对象并插入到请求队列中，请求队列将通知某个工作在同步模式下的工作线程来读取并处理该请求对象。半同步半反应堆模式采用的事件处理模式是reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。半同步半反应堆也可以模拟proactor模式，即由主线程来完成数据的读写。在这种情况下，主线程会将应用程序数据，任务类型等信息封装为一个任务对象，然后将其插入请求队列。工作线程从请求对象取得任务对象以后，可直接处理无需执行读写操作。">
<meta name="author" content="steamdk">
<link rel="canonical" href="https://steamdk.github.io/posts/001%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0dacc8c7e73304b031a6a2212c5729fafb119196b4d02d3b299eb05a4bd0b2a9.css" integrity="sha256-DazIx&#43;czBLAxpqIhLFcp&#43;vsRkZa00C07KZ6wWkvQsqk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://steamdk.github.io/favicon.svg">
<link rel="icon" type="image/png" sizes="16x16" href="https://steamdk.github.io/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="https://steamdk.github.io/favicon.svg">
<link rel="apple-touch-icon" href="https://steamdk.github.io/favicon.svg">
<link rel="mask-icon" href="https://steamdk.github.io/favicon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://steamdk.github.io/posts/001%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">





<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style><meta property="og:url" content="https://steamdk.github.io/posts/001%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
  <meta property="og:site_name" content="项目介绍">
  <meta property="og:title" content="001操作系统">
  <meta property="og:description" content="阻塞IO和非阻塞IO 阻塞的文件描述符为阻塞IO 非阻塞的文件描述符为非阻塞IO 同步IO和异步IO 同步IO向应用程序通知的是IO就绪事件。要求用户代码自行执行读写操作，将数据从内核缓冲区读入用户缓冲区。 异步IO向应用程序通知的是IO完成事件 。由内核来执行IO读写操作。在linux环境下，aio.h头文件定义的函数提供了对异步IO的支持。 事件处理模式 reactor 同步IO模型通常用于实现reactor模式。要求主线程只负责监听文件描述符是否有事件发生，有的话就立即将该事件通知工作线程。 proactor 异步IO模型通常用于实现proactor模式。也可以用同步IO模拟出proactor模式。proactor将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。 Reactor模式的工作流程 主线程往epoll内核事件表中注册socket上的就绪事件。 主线程调用epoll_wait等待socket上有数据可读。 当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。 主线程调用epoll_wait等待socket可写。 当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。 并发模式 半同步半异步模式：同步线程用于处理客户逻辑，异步线程用于处理IO事件。异步线程监听到客户请求后，就将其封装成请求对象并插入到请求队列中，请求队列将通知某个工作在同步模式下的工作线程来读取并处理该请求对象。半同步半反应堆模式采用的事件处理模式是reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。半同步半反应堆也可以模拟proactor模式，即由主线程来完成数据的读写。在这种情况下，主线程会将应用程序数据，任务类型等信息封装为一个任务对象，然后将其插入请求队列。工作线程从请求对象取得任务对象以后，可直接处理无需执行读写操作。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-14T15:21:55+08:00">
    <meta property="article:modified_time" content="2024-09-14T15:21:55+08:00">
    <meta property="article:tag" content="Cpp">
    <meta property="article:tag" content="基础">
      <meta property="og:image" content="https://i.postimg.cc/7hwBy7VS/calcr.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.postimg.cc/7hwBy7VS/calcr.png">
<meta name="twitter:title" content="001操作系统">
<meta name="twitter:description" content="阻塞IO和非阻塞IO

阻塞的文件描述符为阻塞IO
非阻塞的文件描述符为非阻塞IO

同步IO和异步IO

同步IO向应用程序通知的是IO就绪事件。要求用户代码自行执行读写操作，将数据从内核缓冲区读入用户缓冲区。
异步IO向应用程序通知的是IO完成事件 。由内核来执行IO读写操作。在linux环境下，aio.h头文件定义的函数提供了对异步IO的支持。

事件处理模式

reactor 同步IO模型通常用于实现reactor模式。要求主线程只负责监听文件描述符是否有事件发生，有的话就立即将该事件通知工作线程。
proactor 异步IO模型通常用于实现proactor模式。也可以用同步IO模拟出proactor模式。proactor将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。

Reactor模式的工作流程

主线程往epoll内核事件表中注册socket上的就绪事件。
主线程调用epoll_wait等待socket上有数据可读。
当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列。
睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。
主线程调用epoll_wait等待socket可写。
当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。
睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。

并发模式


半同步半异步模式：同步线程用于处理客户逻辑，异步线程用于处理IO事件。异步线程监听到客户请求后，就将其封装成请求对象并插入到请求队列中，请求队列将通知某个工作在同步模式下的工作线程来读取并处理该请求对象。半同步半反应堆模式采用的事件处理模式是reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。半同步半反应堆也可以模拟proactor模式，即由主线程来完成数据的读写。在这种情况下，主线程会将应用程序数据，任务类型等信息封装为一个任务对象，然后将其插入请求队列。工作线程从请求对象取得任务对象以后，可直接处理无需执行读写操作。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://steamdk.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "001操作系统",
      "item": "https://steamdk.github.io/posts/001%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "001操作系统",
  "name": "001操作系统",
  "description": "阻塞IO和非阻塞IO 阻塞的文件描述符为阻塞IO 非阻塞的文件描述符为非阻塞IO 同步IO和异步IO 同步IO向应用程序通知的是IO就绪事件。要求用户代码自行执行读写操作，将数据从内核缓冲区读入用户缓冲区。 异步IO向应用程序通知的是IO完成事件 。由内核来执行IO读写操作。在linux环境下，aio.h头文件定义的函数提供了对异步IO的支持。 事件处理模式 reactor 同步IO模型通常用于实现reactor模式。要求主线程只负责监听文件描述符是否有事件发生，有的话就立即将该事件通知工作线程。 proactor 异步IO模型通常用于实现proactor模式。也可以用同步IO模拟出proactor模式。proactor将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。 Reactor模式的工作流程 主线程往epoll内核事件表中注册socket上的就绪事件。 主线程调用epoll_wait等待socket上有数据可读。 当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。 主线程调用epoll_wait等待socket可写。 当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。 并发模式 半同步半异步模式：同步线程用于处理客户逻辑，异步线程用于处理IO事件。异步线程监听到客户请求后，就将其封装成请求对象并插入到请求队列中，请求队列将通知某个工作在同步模式下的工作线程来读取并处理该请求对象。半同步半反应堆模式采用的事件处理模式是reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。半同步半反应堆也可以模拟proactor模式，即由主线程来完成数据的读写。在这种情况下，主线程会将应用程序数据，任务类型等信息封装为一个任务对象，然后将其插入请求队列。工作线程从请求对象取得任务对象以后，可直接处理无需执行读写操作。\n",
  "keywords": [
    "cpp", "基础"
  ],
  "articleBody": "阻塞IO和非阻塞IO 阻塞的文件描述符为阻塞IO 非阻塞的文件描述符为非阻塞IO 同步IO和异步IO 同步IO向应用程序通知的是IO就绪事件。要求用户代码自行执行读写操作，将数据从内核缓冲区读入用户缓冲区。 异步IO向应用程序通知的是IO完成事件 。由内核来执行IO读写操作。在linux环境下，aio.h头文件定义的函数提供了对异步IO的支持。 事件处理模式 reactor 同步IO模型通常用于实现reactor模式。要求主线程只负责监听文件描述符是否有事件发生，有的话就立即将该事件通知工作线程。 proactor 异步IO模型通常用于实现proactor模式。也可以用同步IO模拟出proactor模式。proactor将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。 Reactor模式的工作流程 主线程往epoll内核事件表中注册socket上的就绪事件。 主线程调用epoll_wait等待socket上有数据可读。 当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。 主线程调用epoll_wait等待socket可写。 当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。 并发模式 半同步半异步模式：同步线程用于处理客户逻辑，异步线程用于处理IO事件。异步线程监听到客户请求后，就将其封装成请求对象并插入到请求队列中，请求队列将通知某个工作在同步模式下的工作线程来读取并处理该请求对象。半同步半反应堆模式采用的事件处理模式是reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。半同步半反应堆也可以模拟proactor模式，即由主线程来完成数据的读写。在这种情况下，主线程会将应用程序数据，任务类型等信息封装为一个任务对象，然后将其插入请求队列。工作线程从请求对象取得任务对象以后，可直接处理无需执行读写操作。\n问题：主线程和工作线程共享请求队列需要加锁。工作线程较少时可能产生请求任务堆积。\n领导者追随者模式\n在IO模型中，同步和异步区分的是内核向应用程序通知的是何种事件，是就绪事件还是完成事件，以及该由谁来完成IO读写，是应用程序还是内核。\n在并发模式中，同步指的是程序完全按照代码序列的顺序执行。异步指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断和信号。\n虚拟地址空间 **虚拟地址是操作系统管理内存的一种方式。**方便不同进程使用的虚拟地址彼此隔离。方便物理内存中不相邻的内存在虚拟地址上视为连续的来使用。虚拟地址和物理地址的映射是通过MMU页表进行的。虚拟内存对实际内存有保护作用。\n什么是进程 进程是系统进行资源分配的基本单位，是程序加载到内存后的执行过程。进程一般由数据段，代码段和进程控制块三部分组成。系统通过进程控制块感知进程的存在并对进程进行控制。由于进程之间空间相互独立，多进程比多线程更安全，一个进程基本上不会影响另外一个进程。\n进程三种状态 创建：创建PCB 就绪 运行 阻塞 终止: 归还PCB 什么是线程 线程是CPU调度的基本单位。一个进程可以包含多个线程，线程自己基本不拥有系统资源，但是它可以和同属于一个进程的其他线程共享进程所拥有的全部资源。多线程之间对内存共享，线程间通信可以直接基于共享内存来实现，比多进程之间通信更轻量。多线程之间切换不需要切换虚拟内存空间、文件描述符等，所以线程的上下文切换也比多进程轻量。\n进程fork以后，遵循读时共享写时复制的机制。\n父子进程长期共享：文件描述符和mmap建立的映射区。\n子进程的进程ID，定时器，未决信号集和父进程不同。\n多进程和多线程的应用场景 一般不同任务间需要大量的通信，使用多线程的场景比多进程多。IO密集型。\n但是多进程有更高的容错性，一个进程的崩溃不会导致整个系统的崩溃，在任务安全性较高的情况下，采用多进程。CPU密集型。\n进程线程的本质区别 进程更安全，一个进程完全不会影响另外的进程。 进程间通信比线程间通信的性能差很多。 线程切换开销更低。 IPC进程间通信55555555555 无名管道pipe（血缘关系的进程） 有名管道fifo （无血缘关系的进程） 共享内存 信号(开销小) 消息队列 信号量 套接字 进程间同步 文件锁 信号量 线程间同步 互斥锁 读写锁(读时共享，写时互斥) 条件变量 信号量(互斥锁的升级版) 自旋锁(可以避免进程或线程上下文的开销) 线程共享资源 文件描述符表（打开的文件） 进程用户ID和进程组ID 进程的**内存地址空间.**text代码段 .data数据段 .bss heap堆区 全局变量 静态变量 每种信号的处理方式 进程的当前目录 线程独享资源 线程栈 寄存器组的值 线程ID 错误返回码errno变量 线程信号屏蔽字 线程优先级 进程调度方式 抢占式：立马停止。 非抢占式：时间片用完或者等待资源时，再调用另一个进程。 进程调度算法 先来先服务 短作业优先 优先级调度 时间片轮转 高响应比优先 管道 管道是一种伪文件，实质为内核缓冲区 大小为4K 内核借用环形队列实现\n管道是半双工的，数据只能单向流动，不可重复读取，只能用于有血缘关系的进程\nLinux命令 find命令，用来查找文件。常用的按照名字查找-name，按照文件类型查找-type，linux常用的文件类型有七种，普通文件，目录文件，管道，套接字，软链接，块设备，字符设备。还可以按照文件大小查询-size。 grep命令，按照文件内容来查找。使用规则是grep option pattern file ps aux curl命令 访问一个网页 df查看磁盘大小 du查看目录大小 free -h 查看内存大小和使用情况 top查看系统的实时负载 netstat -ta 查看监听的TCP stat 获取文件属性 file 查看文件类型 sudo iptables -L 查看防火墙状态 sudo vim etc/sysctl.conf 查看TCP属性 大端字节序和小端字节序 大端字节序：网络字节序（高位存低位） 小端字节序：主机字节序，现代PC机采用小端字节序（低位存低位，高位存高位） 比如0x1f3f5f7f 地址0x1000 0x1001 0x1002 0x1003\n大端法：7f存在0x1003 5f存0x1002 3f存0x1001 1f存0x1000 低存高\n小端法：7f存在0x1000 5f存0x1001 3f存0x1002 1f存0x1003 低存低\nsocket服务器端所用函数 socket 创建socket文件描述符 bind 绑定IP和端口号 listen 监听 accept 接受连接 处理客户端的业务\nsocket客户端所用函数 socket 创建套接字文件描述符 bind 绑定IP和端口号（也可以隐式绑定） connect 尝试连接服务器 处理服务器端的业务\n五种网络IO模型 同步阻塞IO\n同步非阻塞IO\nIO多路复用\n信号驱动IO\n异步IO\nselect与poll、epoll的各自的优缺点和区别 select是跨平台的，windows、linux、unix系统下都有 poll在linux和unix下有 epoll是linux特有，epoll的要义就是高效的监视多个socket 多路IO监听时没有动静，监听会休眠监听。 讲讲epoll的边沿触发和水平触发 水平触发：如果epoll_wait缓冲区有数据则直接返回。 边沿触发：如果一次没有读完epoll_wait缓冲区中的数据，则只有当另外有数据再写入时，才返回。 使用边沿触发和非阻塞IO来达到水平触发的效果，减少了epoll_wait的调用次数，提高了效率。 边沿触发可以只读取缓存区中前面的部分信息，进而分析后面的信息是否有用，如果无用则直接丢弃。 Libevent库 是一个开源的库，封装了socket和IO多路转接，用于高并发服务器的开发。跨平台可移植性好。跨平台，线程安全，基于reactor模式实现的高效网络库。\n协程 协程是一种用户态的轻量级线程。协程的开销远远小于线程的开销。\n协程是一种比线程更加轻量级的存在，一个线程可以拥有多个协程。 无论是进程还是线程，都是由操作系统所管理的。而协程不是被OS所管理，而完全是由程序所控制(也就是在用户态执行)。\n信号 信号是一种不精确通信。\n常用的信号有SIGKILL 9 无条件终止信号，SIGSEGV 11 无效存储访问 SIGPOLL 8 轮询事件信号。\n信号有三种处理方式：忽略，捕获，默认。\nkill命令向进程发送信号\n什么是死锁 因为资源调度的方式不合理或者资源的稀缺性，导致进程间的相互等待。\n死锁的四个必要条件：互斥条件，请求和保持条件，环路等待条件，不可剥夺条件。\n死锁的预防只要破坏死锁产生的四个必要条件。通常采用预先静态分配方法，可以破坏请求和保持条件。\n死锁的避免：采用银行家算法，只要系统处于安全状态，系统便可避免死锁。\n死锁的解决：撤销进程，剥夺资源。\n僵尸进程和孤儿进程 僵尸进程：子进程死亡，而父进程没有进行回收 waitpid回收指定进程 孤儿进程：父进程死亡，而子进程仍然存活，但是系统会让init进程领养孤儿进程。 fork函数 fork函数用来创建子进程 一次调用，两次返回。在父进程中返回子进程的PID，在子进程中返回0\nexec族 在程序中调用另一个可执行程序，但是进程ID不改变。\n网络编程IO 服务器通常需要处理三类事件：IO事件，信号及定时事件。\n事件处理模式：reactor和proactor\n同步IO模型通常用于实现reactor模式\n异步IO则用于实现proactor模式\n什么是reactor模式 它要求主线程只负责监听文件描述符上是否有事件发生，有的话立即将该事件通知工作线程。读写数据，接受新的连接以及处理客户请求均在工作线程中完成。\n什么是proactor模式 它将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。\nmmap存储映射 将磁盘空间映射到进程空间，**使进程可以采用指针的方式操作这段内存，**而不用调用read和write函数。提高了读写的效率，同时也可以实现进程间的通信。\n异步IO原理 底层将数据准备好后，内核会给进程发送一个异步通知信号SIGIO29通知进程，然后进程调用信号处理函数去读数据，没准备好，数据就忙自己的事情。\nselect poll epoll select单个进程打开的文件描述符有上限，为1024或者2048。select对于有响应的事件需要轮询来查找满足要求的事件。每次调用select都需要把文件描述符集合从用户态拷贝到内核态。 poll描述fd的集合是链式的，解决了打开文件描述符数量的限制。同样需要轮询满足事件的文件描述符。也需要进行用户态和内核态的文件描述符拷贝。poll是水平触发。 epoll使用了mmap内存映射技术和红黑树的数据结构。通过三个函数来监听多个文件描述符，同时不随数量的上升效率呈线性的下降。mmap内存读写快于IO读写，及时共享映射内存的改变。 ",
  "wordCount" : "4369",
  "inLanguage": "zh",
  "image": "https://i.postimg.cc/7hwBy7VS/calcr.png","datePublished": "2024-09-14T15:21:55+08:00",
  "dateModified": "2024-09-14T15:21:55+08:00",
  "author":{
    "@type": "Person",
    "name": "steamdk"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://steamdk.github.io/posts/001%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "项目介绍",
    "logo": {
      "@type": "ImageObject",
      "url": "https://steamdk.github.io/favicon.svg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://steamdk.github.io/" accesskey="h" title="项目介绍 (Alt + H)">项目介绍</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://steamdk.github.io/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://steamdk.github.io/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      001操作系统
    </h1>
    <div class="post-meta"><span title='2024-09-14 15:21:55 +0800 CST'>2024-09-14</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;steamdk

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e9%98%bb%e5%a1%9eio%e5%92%8c%e9%9d%9e%e9%98%bb%e5%a1%9eio" aria-label="阻塞IO和非阻塞IO">阻塞IO和非阻塞IO</a></li>
                <li>
                    <a href="#%e5%90%8c%e6%ad%a5io%e5%92%8c%e5%bc%82%e6%ad%a5io" aria-label="同步IO和异步IO">同步IO和异步IO</a></li>
                <li>
                    <a href="#%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e6%a8%a1%e5%bc%8f" aria-label="事件处理模式">事件处理模式</a></li>
                <li>
                    <a href="#reactor%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" aria-label="Reactor模式的工作流程">Reactor模式的工作流程</a></li>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e6%a8%a1%e5%bc%8f" aria-label="并发模式">并发模式</a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4" aria-label="虚拟地址空间">虚拟地址空间</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%bf%9b%e7%a8%8b" aria-label="什么是进程">什么是进程</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e4%b8%89%e7%a7%8d%e7%8a%b6%e6%80%81" aria-label="进程三种状态">进程三种状态</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b" aria-label="什么是线程">什么是线程</a></li>
                <li>
                    <a href="#%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%92%8c%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="多进程和多线程的应用场景">多进程和多线程的应用场景</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%9c%ac%e8%b4%a8%e5%8c%ba%e5%88%ab" aria-label="进程线程的本质区别">进程线程的本质区别</a></li>
                <li>
                    <a href="#ipc%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a155555555555" aria-label="IPC进程间通信55555555555">IPC进程间通信55555555555</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e9%97%b4%e5%90%8c%e6%ad%a5" aria-label="进程间同步">进程间同步</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e9%97%b4%e5%90%8c%e6%ad%a5" aria-label="线程间同步">线程间同步</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e8%b5%84%e6%ba%90" aria-label="线程共享资源">线程共享资源</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e7%8b%ac%e4%ba%ab%e8%b5%84%e6%ba%90" aria-label="线程独享资源">线程独享资源</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e6%96%b9%e5%bc%8f" aria-label="进程调度方式">进程调度方式</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95" aria-label="进程调度算法">进程调度算法</a></li>
                <li>
                    <a href="#%e7%ae%a1%e9%81%93" aria-label="管道">管道</a></li>
                <li>
                    <a href="#linux%e5%91%bd%e4%bb%a4" aria-label="Linux命令">Linux命令</a></li>
                <li>
                    <a href="#%e5%a4%a7%e7%ab%af%e5%ad%97%e8%8a%82%e5%ba%8f%e5%92%8c%e5%b0%8f%e7%ab%af%e5%ad%97%e8%8a%82%e5%ba%8f" aria-label="大端字节序和小端字节序">大端字节序和小端字节序</a></li>
                <li>
                    <a href="#socket%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%af%e6%89%80%e7%94%a8%e5%87%bd%e6%95%b0" aria-label="socket服务器端所用函数">socket服务器端所用函数</a></li>
                <li>
                    <a href="#socket%e5%ae%a2%e6%88%b7%e7%ab%af%e6%89%80%e7%94%a8%e5%87%bd%e6%95%b0" aria-label="socket客户端所用函数">socket客户端所用函数</a></li>
                <li>
                    <a href="#%e4%ba%94%e7%a7%8d%e7%bd%91%e7%bb%9cio%e6%a8%a1%e5%9e%8b" aria-label="五种网络IO模型">五种网络IO模型</a></li>
                <li>
                    <a href="#select%e4%b8%8epollepoll%e7%9a%84%e5%90%84%e8%87%aa%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e5%92%8c%e5%8c%ba%e5%88%ab" aria-label="select与poll、epoll的各自的优缺点和区别">select与poll、epoll的各自的优缺点和区别</a></li>
                <li>
                    <a href="#%e8%ae%b2%e8%ae%b2epoll%e7%9a%84%e8%be%b9%e6%b2%bf%e8%a7%a6%e5%8f%91%e5%92%8c%e6%b0%b4%e5%b9%b3%e8%a7%a6%e5%8f%91" aria-label="讲讲epoll的边沿触发和水平触发">讲讲epoll的边沿触发和水平触发</a></li>
                <li>
                    <a href="#libevent%e5%ba%93" aria-label="Libevent库">Libevent库</a></li>
                <li>
                    <a href="#%e5%8d%8f%e7%a8%8b" aria-label="协程">协程</a></li>
                <li>
                    <a href="#%e4%bf%a1%e5%8f%b7" aria-label="信号">信号</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%ad%bb%e9%94%81" aria-label="什么是死锁">什么是死锁</a></li>
                <li>
                    <a href="#%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%e5%92%8c%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b" aria-label="僵尸进程和孤儿进程">僵尸进程和孤儿进程</a></li>
                <li>
                    <a href="#fork%e5%87%bd%e6%95%b0" aria-label="fork函数">fork函数</a></li>
                <li>
                    <a href="#exec%e6%97%8f" aria-label="exec族">exec族</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8bio" aria-label="网络编程IO">网络编程IO</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afreactor%e6%a8%a1%e5%bc%8f" aria-label="什么是reactor模式">什么是reactor模式</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afproactor%e6%a8%a1%e5%bc%8f" aria-label="什么是proactor模式">什么是proactor模式</a></li>
                <li>
                    <a href="#mmap%e5%ad%98%e5%82%a8%e6%98%a0%e5%b0%84" aria-label="mmap存储映射">mmap存储映射</a></li>
                <li>
                    <a href="#%e5%bc%82%e6%ad%a5io%e5%8e%9f%e7%90%86" aria-label="异步IO原理">异步IO原理</a></li>
                <li>
                    <a href="#select-poll-epoll" aria-label="select poll epoll">select poll epoll</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="阻塞io和非阻塞io">阻塞IO和非阻塞IO<a hidden class="anchor" aria-hidden="true" href="#阻塞io和非阻塞io">#</a></h2>
<ul>
<li><strong>阻塞的文件描述符</strong>为阻塞IO</li>
<li>非阻塞的文件描述符为非阻塞IO</li>
</ul>
<h2 id="同步io和异步io">同步IO和异步IO<a hidden class="anchor" aria-hidden="true" href="#同步io和异步io">#</a></h2>
<ul>
<li>同步IO向应用程序通知的是<strong>IO就绪事件</strong>。要求用户代码自行执行读写操作，将数据从内核缓冲区读入用户缓冲区。</li>
<li>异步IO向应用程序通知的是<strong>IO完成事件</strong> 。由内核来执行IO读写操作。在linux环境下，aio.h头文件定义的函数提供了对异步IO的支持。</li>
</ul>
<h2 id="事件处理模式">事件处理模式<a hidden class="anchor" aria-hidden="true" href="#事件处理模式">#</a></h2>
<ol>
<li>reactor 同步IO模型通常用于实现reactor模式。要求主线程只负责监听文件描述符是否有事件发生，有的话就立即将该事件通知工作线程。</li>
<li>proactor 异步IO模型通常用于实现proactor模式。也可以用同步IO模拟出proactor模式。proactor将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</li>
</ol>
<h2 id="reactor模式的工作流程">Reactor模式的工作流程<a hidden class="anchor" aria-hidden="true" href="#reactor模式的工作流程">#</a></h2>
<ol>
<li>主线程往epoll内核事件表中注册socket上的就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li>
</ol>
<h2 id="并发模式">并发模式<a hidden class="anchor" aria-hidden="true" href="#并发模式">#</a></h2>
<ol>
<li>
<p>半同步半异步模式：同步线程用于处理客户逻辑，异步线程用于处理IO事件。异步线程监听到客户请求后，就将其封装成请求对象并插入到请求队列中，请求队列将通知某个工作在同步模式下的工作线程来读取并处理该请求对象。半同步半反应堆模式采用的事件处理模式是reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。半同步半反应堆也可以模拟proactor模式，即<strong>由主线程来完成数据的读写</strong>。在这种情况下，主线程会将应用程序数据，<strong>任务类型等信息封装为一个任务对象</strong>，<strong>然后将其插入请求队列</strong>。<strong>工作线程从请求对象取得任务对象以后，可直接处理无需执行读写操作。</strong></p>
<p>问题：主线程和工作线程共享请求队列需要加锁。工作线程较少时可能产生请求任务堆积。</p>
</li>
<li>
<p>领导者追随者模式</p>
</li>
</ol>
<ul>
<li>
<p>在IO模型中，同步和异步区分的是内核向应用程序通知的是何种事件，是就绪事件还是完成事件，以及该由谁来完成IO读写，是应用程序还是内核。</p>
</li>
<li>
<p>在并发模式中，同步指的是程序完全按照代码序列的顺序执行。异步指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断和信号。</p>
</li>
</ul>
<h2 id="虚拟地址空间">虚拟地址空间<a hidden class="anchor" aria-hidden="true" href="#虚拟地址空间">#</a></h2>
<p>**虚拟地址是操作系统管理内存的一种方式。**方便不同进程使用的虚拟地址彼此隔离。方便物理内存中不相邻的内存在虚拟地址上视为连续的来使用。<strong>虚拟地址和物理地址的映射是通过MMU页表进行的</strong>。虚拟内存对实际内存有保护作用。</p>
<h2 id="什么是进程">什么是进程<a hidden class="anchor" aria-hidden="true" href="#什么是进程">#</a></h2>
<p><strong>进程是系统进行资源分配的基本单位，是程序加载到内存后的执行过程。<strong>进程一般由数据段，代码段和进程控制块三部分组成。系统通过进程控制块感知进程的存在并对进程进行控制。由于</strong>进程之间空间相互独立</strong>，多进程比多线程更安全，一个进程基本上不会影响另外一个进程。</p>
<h2 id="进程三种状态">进程三种状态<a hidden class="anchor" aria-hidden="true" href="#进程三种状态">#</a></h2>
<ol>
<li>创建：创建PCB</li>
<li><strong>就绪</strong></li>
<li><strong>运行</strong></li>
<li><strong>阻塞</strong></li>
<li>终止: 归还PCB</li>
</ol>
<h2 id="什么是线程">什么是线程<a hidden class="anchor" aria-hidden="true" href="#什么是线程">#</a></h2>
<p><strong>线程是CPU调度的基本单位。<strong>一个进程可以包含多个线程，<strong>线程自己基本不拥有系统资源</strong>，但是它可以和同属于一个进程的其他线程共享进程所拥有的全部资源。多线程之间对内存共享，线程间通信可以直接基于</strong>共享内存</strong>来实现，比多进程之间通信更轻量。多线程之间切换<strong>不需要切换虚拟内存空间、文件描述符</strong>等，所以线程的上下文切换也比多进程轻量。</p>
<p>进程fork以后，遵循<strong>读时共享写时复制</strong>的机制。</p>
<p>父子进程长期共享：<strong>文件描述符和mmap建立的映射区。</strong></p>
<p>子进程的<strong>进程ID，定时器，未决信号集和父进程不同</strong>。</p>
<h2 id="多进程和多线程的应用场景">多进程和多线程的应用场景<a hidden class="anchor" aria-hidden="true" href="#多进程和多线程的应用场景">#</a></h2>
<ol>
<li>
<p>一般不同任务间需要大量的通信，使用多线程的场景比多进程多。<strong>IO密集型。</strong></p>
</li>
<li>
<p>但是多进程有更高的容错性，一个进程的崩溃不会导致整个系统的崩溃，<strong>在任务安全性较高的情况下</strong>，采用多进程。<strong>CPU密集型。</strong></p>
</li>
</ol>
<h2 id="进程线程的本质区别">进程线程的本质区别<a hidden class="anchor" aria-hidden="true" href="#进程线程的本质区别">#</a></h2>
<ol>
<li>进程<strong>更安全</strong>，一个进程完全不会影响另外的进程。</li>
<li>进程间通信比线程间<strong>通信的性能差</strong>很多。</li>
<li>线程切换开销更低。</li>
</ol>
<h2 id="ipc进程间通信55555555555">IPC进程间通信55555555555<a hidden class="anchor" aria-hidden="true" href="#ipc进程间通信55555555555">#</a></h2>
<ol>
<li><strong>无名管道pipe（血缘关系的进程）</strong></li>
<li><strong>有名管道fifo （无血缘关系的进程）</strong></li>
<li><strong>共享内存</strong></li>
<li><strong>信号(开销小)</strong></li>
<li><strong>消息队列</strong></li>
<li>信号量</li>
<li>套接字</li>
</ol>
<h2 id="进程间同步">进程间同步<a hidden class="anchor" aria-hidden="true" href="#进程间同步">#</a></h2>
<ol>
<li>文件锁</li>
<li>信号量</li>
</ol>
<h2 id="线程间同步">线程间同步<a hidden class="anchor" aria-hidden="true" href="#线程间同步">#</a></h2>
<ol>
<li>互斥锁</li>
<li>读写锁(读时共享，写时互斥)</li>
<li>条件变量</li>
<li>信号量(互斥锁的升级版)</li>
<li>自旋锁(可以避免进程或线程上下文的开销)</li>
</ol>
<h2 id="线程共享资源">线程共享资源<a hidden class="anchor" aria-hidden="true" href="#线程共享资源">#</a></h2>
<ol>
<li>文件描述符表（打开的文件）</li>
<li><strong>进程用户ID和进程组ID</strong></li>
<li>进程的**内存地址空间.**text代码段 .data数据段 .bss heap堆区 <strong>全局变量 静态变量</strong></li>
<li><strong>每种信号的处理方式</strong></li>
<li><strong>进程的当前目录</strong></li>
</ol>
<h2 id="线程独享资源">线程独享资源<a hidden class="anchor" aria-hidden="true" href="#线程独享资源">#</a></h2>
<ol>
<li><strong>线程栈</strong></li>
<li><strong>寄存器组的值</strong></li>
<li>线程ID</li>
<li>错误返回码errno变量</li>
<li><strong>线程信号屏蔽字</strong></li>
<li><strong>线程优先级</strong></li>
</ol>
<h2 id="进程调度方式">进程调度方式<a hidden class="anchor" aria-hidden="true" href="#进程调度方式">#</a></h2>
<ol>
<li>抢占式：立马停止。</li>
<li>非抢占式：时间片用完或者等待资源时，再调用另一个进程。</li>
</ol>
<h2 id="进程调度算法">进程调度算法<a hidden class="anchor" aria-hidden="true" href="#进程调度算法">#</a></h2>
<ol>
<li>先来先服务</li>
<li>短作业优先</li>
<li>优先级调度</li>
<li>时间片轮转</li>
<li>高响应比优先</li>
</ol>
<h2 id="管道">管道<a hidden class="anchor" aria-hidden="true" href="#管道">#</a></h2>
<p><strong>管道是一种伪文件</strong>，<strong>实质为内核缓冲区 大小为4K 内核借用环形队列实现</strong></p>
<p>管道是半双工的，数据只能单向流动，不可重复读取，<strong>只能用于有血缘关系的进程</strong></p>
<h2 id="linux命令">Linux命令<a hidden class="anchor" aria-hidden="true" href="#linux命令">#</a></h2>
<ol>
<li>find命令，用来查找文件。常用的按照名字查找-name，按照文件类型查找-type，linux常用的文件类型有七种，普通文件，目录文件，管道，套接字，软链接，块设备，字符设备。还可以按照文件大小查询-size。</li>
<li>grep命令，按照文件内容来查找。使用规则是grep option pattern file</li>
<li>ps aux</li>
<li>curl命令 访问一个网页</li>
<li><strong>df查看磁盘大小</strong></li>
<li><strong>du查看目录大小</strong></li>
<li><strong>free -h 查看内存大小和使用情况</strong></li>
<li><strong>top查看系统的实时负载</strong></li>
<li><strong>netstat -ta 查看监听的TCP</strong></li>
<li>stat 获取文件属性</li>
<li><strong>file 查看文件类型</strong></li>
<li>sudo iptables -L 查看防火墙状态</li>
<li>sudo vim etc/sysctl.conf 查看TCP属性</li>
</ol>
<h2 id="大端字节序和小端字节序">大端字节序和小端字节序<a hidden class="anchor" aria-hidden="true" href="#大端字节序和小端字节序">#</a></h2>
<ol>
<li>大端字节序：<strong>网络字节序（高位存低位）</strong></li>
<li>小端字节序：主机字节序，<strong>现代PC机</strong>采用小端字节序（低位存低位，高位存高位）</li>
</ol>
<blockquote>
<p>比如0x1f3f5f7f  地址0x1000 0x1001 0x1002 0x1003</p>
<p>大端法：7f存在0x1003 5f存0x1002 3f存0x1001 1f存0x1000 低存高</p>
<p>小端法：7f存在0x1000 5f存0x1001 3f存0x1002 1f存0x1003 低存低</p>
</blockquote>
<h2 id="socket服务器端所用函数">socket服务器端所用函数<a hidden class="anchor" aria-hidden="true" href="#socket服务器端所用函数">#</a></h2>
<blockquote>
<p>socket 创建socket文件描述符 bind 绑定IP和端口号 listen 监听  accept 接受连接 处理客户端的业务</p>
</blockquote>
<h2 id="socket客户端所用函数">socket客户端所用函数<a hidden class="anchor" aria-hidden="true" href="#socket客户端所用函数">#</a></h2>
<blockquote>
<p>socket 创建套接字文件描述符 bind 绑定IP和端口号（也可以隐式绑定） connect 尝试连接服务器 处理服务器端的业务</p>
</blockquote>
<h2 id="五种网络io模型">五种网络IO模型<a hidden class="anchor" aria-hidden="true" href="#五种网络io模型">#</a></h2>
<ol>
<li>
<p>同步阻塞IO</p>
</li>
<li>
<p>同步非阻塞IO</p>
</li>
<li>
<p>IO多路复用</p>
</li>
<li>
<p>信号驱动IO</p>
</li>
<li>
<p>异步IO</p>
</li>
</ol>
<h2 id="select与pollepoll的各自的优缺点和区别">select与poll、epoll的各自的优缺点和区别<a hidden class="anchor" aria-hidden="true" href="#select与pollepoll的各自的优缺点和区别">#</a></h2>
<ol>
<li>select是跨平台的，windows、linux、unix系统下都有</li>
<li>poll在linux和unix下有 epoll是linux特有，epoll的要义就是高效的监视多个socket</li>
<li>多路IO监听时没有动静，监听会休眠监听。</li>
</ol>
<h2 id="讲讲epoll的边沿触发和水平触发">讲讲epoll的边沿触发和水平触发<a hidden class="anchor" aria-hidden="true" href="#讲讲epoll的边沿触发和水平触发">#</a></h2>
<ol>
<li><strong>水平触发：<strong>如果</strong>epoll_wait缓冲区有数据</strong>则直接返回。</li>
<li>边沿触发：<strong>如果一次没有读完epoll_wait缓冲区中的数据，则只有当另外有数据再写入时，才返回。</strong> 使用边沿触发和非阻塞IO来达到水平触发的效果，减少了epoll_wait的调用次数，提高了效率。 边沿触发可以只读取缓存区中前面的部分信息，进而分析后面的信息是否有用，如果无用则直接丢弃。</li>
</ol>
<h2 id="libevent库">Libevent库<a hidden class="anchor" aria-hidden="true" href="#libevent库">#</a></h2>
<p>是一个开源的库，封装了socket和IO多路转接，用于高并发服务器的开发。跨平台可移植性好。跨平台，线程安全，基于reactor模式实现的高效网络库。</p>
<h2 id="协程">协程<a hidden class="anchor" aria-hidden="true" href="#协程">#</a></h2>
<p><strong>协程是一种用户态的轻量级线程。协程的开销远远小于线程的开销。</strong></p>
<p>协程是一种比线程更加轻量级的存在，一个线程可以拥有多个协程。 无论是进程还是线程，都是由操作系统所管理的。而协程不是被OS所管理，而完全是由程序所控制(也就是在用户态执行)。</p>
<h2 id="信号">信号<a hidden class="anchor" aria-hidden="true" href="#信号">#</a></h2>
<p><strong>信号是一种不精确通信。</strong></p>
<p><strong>常用的信号有SIGKILL 9 无条件终止信号，SIGSEGV 11 无效存储访问 SIGPOLL 8 轮询事件信号。</strong></p>
<p>信号有三种处理方式：<strong>忽略，捕获，默认。</strong></p>
<p>kill命令向进程发送信号</p>
<h2 id="什么是死锁">什么是死锁<a hidden class="anchor" aria-hidden="true" href="#什么是死锁">#</a></h2>
<p>因为资源调度的方式不合理或者资源的稀缺性，导致进程间的相互等待。</p>
<p>死锁的四个必要条件：<strong>互斥条件，请求和保持条件，环路等待条件，不可剥夺条件。</strong></p>
<p>死锁的预防只要破坏死锁产生的四个必要条件。通常采用<strong>预先静态分配方法</strong>，可以破坏请求和保持条件。</p>
<p><strong>死锁的避免：采用银行家算法，只要系统处于安全状态，系统便可避免死锁。</strong></p>
<p>死锁的解决：撤销进程，剥夺资源。</p>
<h2 id="僵尸进程和孤儿进程">僵尸进程和孤儿进程<a hidden class="anchor" aria-hidden="true" href="#僵尸进程和孤儿进程">#</a></h2>
<ol>
<li>僵尸进程：子进程死亡，而父进程没有进行回收   waitpid回收指定进程</li>
<li>孤儿进程：父进程死亡，而子进程仍然存活，但是系统会让init进程领养孤儿进程。</li>
</ol>
<h2 id="fork函数">fork函数<a hidden class="anchor" aria-hidden="true" href="#fork函数">#</a></h2>
<p>fork函数用来创建子进程 一次调用，两次返回。<strong>在父进程中返回子进程的PID</strong>，在子进程中返回0</p>
<h2 id="exec族">exec族<a hidden class="anchor" aria-hidden="true" href="#exec族">#</a></h2>
<p><strong>在程序中调用另一个可执行程序，但是进程ID不改变。</strong></p>
<h2 id="网络编程io">网络编程IO<a hidden class="anchor" aria-hidden="true" href="#网络编程io">#</a></h2>
<p>服务器通常需要处理三类事件：<strong>IO事件，信号及定时事件。</strong></p>
<p>事件处理模式：<strong>reactor和proactor</strong></p>
<p>同步IO模型通常用于实现reactor模式</p>
<p>异步IO则用于实现proactor模式</p>
<h2 id="什么是reactor模式">什么是reactor模式<a hidden class="anchor" aria-hidden="true" href="#什么是reactor模式">#</a></h2>
<p>它要<strong>求主线程只负责监听文件描述符上是否有事件发生</strong>，有的话立即将该事件通知工作线程。读写数据，接受新的连接以及处理客户请求均在工作线程中完成。</p>
<h2 id="什么是proactor模式">什么是proactor模式<a hidden class="anchor" aria-hidden="true" href="#什么是proactor模式">#</a></h2>
<p>它将所有<strong>IO操作都交给主线程和内核来处理</strong>，工作线程仅仅<strong>负责业务逻辑。</strong></p>
<h2 id="mmap存储映射">mmap存储映射<a hidden class="anchor" aria-hidden="true" href="#mmap存储映射">#</a></h2>
<p>将磁盘空间映射到进程空间，**使进程可以采用指针的方式操作这段内存，**而不用调用read和write函数。提高了读写的效率，同时也可以实现进程间的通信。</p>
<h2 id="异步io原理">异步IO原理<a hidden class="anchor" aria-hidden="true" href="#异步io原理">#</a></h2>
<p>底层将数据准备好后，<strong>内核会给进程发送一个异步通知信号SIGIO29通知进程</strong>，然后进程调用信号处理函数去读数据，没准备好，数据就忙自己的事情。</p>
<h2 id="select-poll-epoll">select poll epoll<a hidden class="anchor" aria-hidden="true" href="#select-poll-epoll">#</a></h2>
<ol>
<li><strong>select单个进程打开的文件描述符有上限</strong>，为1024或者2048。<strong>select对于有响应的事件需要轮询来查找满足要求的事件。每次调用select都需要把文件描述符集合从用户态拷贝到内核态。</strong></li>
<li>poll描述fd的集合是链式的，<strong>解决了打开文件描述符数量的限制</strong>。同样需要轮询满足事件的文件描述符。也需要进行用户态和内核态的文件描述符拷贝。poll是水平触发。</li>
<li>epoll使用了<strong>mmap内存映射技术</strong>和<strong>红黑树的数据结构</strong>。通过三个函数来监听多个文件描述符，同时不随数量的上升效率呈线性的下降。mmap内存读写快于IO读写，及时共享映射内存的改变。</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://steamdk.github.io/tags/cpp/">Cpp</a></li>
      <li><a href="https://steamdk.github.io/tags/%E5%9F%BA%E7%A1%80/">基础</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://steamdk.github.io/posts/002%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
    <span class="title">« 上一页</span>
    <br>
    <span>002计算机网络</span>
  </a>
  <a class="next" href="https://steamdk.github.io/posts/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/">
    <span class="title">下一页 »</span>
    <br>
    <span>英语学习</span>
  </a>
</nav>

  </footer><div id="tw-comment"></div>
<script>
    
    const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "light" : "dark";
    const setGiscusTheme = () => {
        const sendMessage = (message) => {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (iframe) {
                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');
            }
        }
        sendMessage({setConfig: {theme: getStoredTheme()}})
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "steamdk\/steamdk.github.io",
            "data-repo-id": "R_kgDONN_Y2g",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDONN_Y2s4CkVh9",
            "data-mapping": "pathname",
            "data-strict": "0",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "zh-CN",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
                ([key, value]) => giscusScript.setAttribute(key, value));
        document.querySelector("#tw-comment").appendChild(giscusScript);

        
        const themeSwitcher = document.querySelector("#theme-toggle");
        if (themeSwitcher) {
            themeSwitcher.addEventListener("click", setGiscusTheme);
        }
        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");
        if (themeFloatSwitcher) {
            themeFloatSwitcher.addEventListener("click", setGiscusTheme);
        }
    });
</script>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://github.com/steamdk/steamdk.github.io">©2024 项目介绍</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>


<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js"
  integrity="sha512-9ZKhgaFdKlsELap/dGw3Iaz5Bj+Las0XXZiRKYZaN9QArg6FtkD5rULNmNH4rTCTFxjPiBGr3MX8smRADRorDA=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
  var OSName = "unknown";
  var navApp = navigator.userAgent.toLowerCase();
  switch (true) {
    case (navApp.indexOf("win") != -1):
      OSName = "windows";
      break;
    case (navApp.indexOf("mac") != -1):
      OSName = "apple";
      break;
    case (navApp.indexOf("linux") != -1):
      OSName = "linux";
      break;
    case (navApp.indexOf("x11") != -1):
      OSName = "unix";
      break;
  }

  const images = Array.from(document.querySelectorAll(".post-content img"));
  images.forEach(img => {
    mediumZoom(img, {
      margin: 1,    
      
      container: null,  
      template: null,  
      
    });
  });

  if (OSName == "windows") {
    document.body.className += ' win11'
  }
</script>






<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
