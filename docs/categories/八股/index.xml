<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>八股 on 项目介绍</title>
    <link>https://steamdk.github.io/categories/%E5%85%AB%E8%82%A1/</link>
    <description>Recent content in 八股 on 项目介绍</description>
    <image>
      <title>项目介绍</title>
      <url>https://i.postimg.cc/7hwBy7VS/calcr.png</url>
      <link>https://i.postimg.cc/7hwBy7VS/calcr.png</link>
    </image>
    <generator>Hugo -- 0.138.0</generator>
    <language>zh</language>
    <copyright>©2024 项目介绍</copyright>
    <lastBuildDate>Sat, 14 Sep 2024 21:58:12 +0800</lastBuildDate>
    <atom:link href="https://steamdk.github.io/categories/%E5%85%AB%E8%82%A1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>003C&#43;&#43;语言</title>
      <link>https://steamdk.github.io/posts/003c&#43;&#43;%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Sat, 14 Sep 2024 21:58:12 +0800</pubDate>
      <guid>https://steamdk.github.io/posts/003c&#43;&#43;%E8%AF%AD%E8%A8%80/</guid>
      <description>&lt;h2 id=&#34;逻辑用语千万条第一首先往里套&#34;&gt;逻辑用语千万条，第一首先往里套。&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先，其次，然后，最后。&lt;/li&gt;
&lt;li&gt;第一，第二，第三，第四。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;书籍&#34;&gt;书籍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;《C++ primer》 第五版&lt;/li&gt;
&lt;li&gt;《后台开发》 徐晓鑫&lt;/li&gt;
&lt;li&gt;《linux高性能服务器编程》 游双&lt;/li&gt;
&lt;li&gt;《redis设计与实现》黄健宏&lt;/li&gt;
&lt;li&gt;《muduo库》陈硕&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;static&#34;&gt;static&lt;/h2&gt;
&lt;p&gt;static的使用可以分为两类，一类是用在&lt;strong&gt;普通变量和函数&lt;/strong&gt;上，另一类是&lt;strong&gt;用在类中&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>002计算机网络</title>
      <link>https://steamdk.github.io/posts/002%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Sat, 14 Sep 2024 21:57:51 +0800</pubDate>
      <guid>https://steamdk.github.io/posts/002%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>&lt;h2 id=&#34;tcp头部&#34;&gt;TCP头部&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;16位源端口&lt;/li&gt;
&lt;li&gt;16位目的端口&lt;/li&gt;
&lt;li&gt;32位序号&lt;/li&gt;
&lt;li&gt;32位确认序号&lt;/li&gt;
&lt;li&gt;4位TCP头部长度  单位为4字节&lt;/li&gt;
&lt;li&gt;6位标志位&lt;/li&gt;
&lt;li&gt;16位滑动窗口&lt;/li&gt;
&lt;li&gt;16位校验和&lt;/li&gt;
&lt;li&gt;16位紧急指针&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：&lt;strong&gt;TCP的包没有IP地址&lt;/strong&gt;，只有源端口和目的端口。一个TCP连接需要4个元组来表示一个连接。（源端口，目的端口，源IP，目的IP）&lt;/p&gt;</description>
    </item>
    <item>
      <title>001操作系统</title>
      <link>https://steamdk.github.io/posts/001%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 14 Sep 2024 15:21:55 +0800</pubDate>
      <guid>https://steamdk.github.io/posts/001%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;h2 id=&#34;阻塞io和非阻塞io&#34;&gt;阻塞IO和非阻塞IO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;阻塞的文件描述符&lt;/strong&gt;为阻塞IO&lt;/li&gt;
&lt;li&gt;非阻塞的文件描述符为非阻塞IO&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;同步io和异步io&#34;&gt;同步IO和异步IO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;同步IO向应用程序通知的是&lt;strong&gt;IO就绪事件&lt;/strong&gt;。要求用户代码自行执行读写操作，将数据从内核缓冲区读入用户缓冲区。&lt;/li&gt;
&lt;li&gt;异步IO向应用程序通知的是&lt;strong&gt;IO完成事件&lt;/strong&gt; 。由内核来执行IO读写操作。在linux环境下，aio.h头文件定义的函数提供了对异步IO的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事件处理模式&#34;&gt;事件处理模式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;reactor 同步IO模型通常用于实现reactor模式。要求主线程只负责监听文件描述符是否有事件发生，有的话就立即将该事件通知工作线程。&lt;/li&gt;
&lt;li&gt;proactor 异步IO模型通常用于实现proactor模式。也可以用同步IO模拟出proactor模式。proactor将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;reactor模式的工作流程&#34;&gt;Reactor模式的工作流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;主线程往epoll内核事件表中注册socket上的就绪事件。&lt;/li&gt;
&lt;li&gt;主线程调用epoll_wait等待socket上有数据可读。&lt;/li&gt;
&lt;li&gt;当socket上有数据可读时，epoll_wait通知主线程。主线程将socket可读事件放入请求队列。&lt;/li&gt;
&lt;li&gt;睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。&lt;/li&gt;
&lt;li&gt;主线程调用epoll_wait等待socket可写。&lt;/li&gt;
&lt;li&gt;当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。&lt;/li&gt;
&lt;li&gt;睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;并发模式&#34;&gt;并发模式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;半同步半异步模式：同步线程用于处理客户逻辑，异步线程用于处理IO事件。异步线程监听到客户请求后，就将其封装成请求对象并插入到请求队列中，请求队列将通知某个工作在同步模式下的工作线程来读取并处理该请求对象。半同步半反应堆模式采用的事件处理模式是reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。半同步半反应堆也可以模拟proactor模式，即&lt;strong&gt;由主线程来完成数据的读写&lt;/strong&gt;。在这种情况下，主线程会将应用程序数据，&lt;strong&gt;任务类型等信息封装为一个任务对象&lt;/strong&gt;，&lt;strong&gt;然后将其插入请求队列&lt;/strong&gt;。&lt;strong&gt;工作线程从请求对象取得任务对象以后，可直接处理无需执行读写操作。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
